{
  "examples": [
    {
      "id": "example-62",
      "name": "Temp Directory Misuse Bug",
      "description": "Bug này là do sử dụng java.io.tmpdir trong unit test, khiến test phụ thuộc môi trường và trở nên flaky; fix bằng cách chuyển sang thư mục target/ để đảm bảo tính ổn định và reproducible.",
      "buggy": "    public void setup(){\n        //Create the temp dir\n        final File sysTempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n        String dirName = UUID.randomUUID().toString();\n        tempDir = new File(sysTempDir, dirName);\n        productDir = new File(tempDir,PROJECT_ID);\n        tempResourcesDir = new File(productDir,TMP_RESOURCES);\n        generatedHomeDir = new File(tempResourcesDir,GENERATED_HOME);\n        pluginsDir = new File(generatedHomeDir,PLUGINS);\n        bundledPluginsDir = new File(generatedHomeDir,BUNDLED_PLUGINS);\n\n        //setup maven mocks\n        MavenProject project = mock(MavenProject.class);\n        Build build = mock(Build.class);\n\n        //Mockito throws NoClassDefFoundError: org/apache/maven/project/ProjectBuilderConfiguration\n        //when mocking the session\n        //MavenSession session = mock(MavenSession.class);\n\n        PluginManager pluginManager = mock(PluginManager.class);\n        List<MavenProject> reactor = Collections.<MavenProject>emptyList();\n        ctx = mock(MavenContext.class);\n\n        when(build.getDirectory()).thenReturn(tempDir.getAbsolutePath());\n        when(project.getBuild()).thenReturn(build);\n        when(ctx.getProject()).thenReturn(project);\n        when(ctx.getLog()).thenReturn(new SystemStreamLog());\n        when(ctx.getReactor()).thenReturn(reactor);\n        when(ctx.getSession()).thenReturn(null);\n        when(ctx.getPluginManager()).thenReturn(pluginManager);\n\n        goals = new MavenGoals(ctx);\n    }\n",
      "fixed": "    public void setup(){\n        //Create the temp dir\n        final File sysTempDir = new File(\"target\");\n        String dirName = UUID.randomUUID().toString();\n        tempDir = new File(sysTempDir, dirName);\n        productDir = new File(tempDir,PROJECT_ID);\n        tempResourcesDir = new File(productDir,TMP_RESOURCES);\n        generatedHomeDir = new File(tempResourcesDir,GENERATED_HOME);\n        pluginsDir = new File(generatedHomeDir,PLUGINS);\n        bundledPluginsDir = new File(generatedHomeDir,BUNDLED_PLUGINS);\n\n        //setup maven mocks\n        MavenProject project = mock(MavenProject.class);\n        Build build = mock(Build.class);\n\n        //Mockito throws NoClassDefFoundError: org/apache/maven/project/ProjectBuilderConfiguration\n        //when mocking the session\n        //MavenSession session = mock(MavenSession.class);\n\n        PluginManager pluginManager = mock(PluginManager.class);\n        List<MavenProject> reactor = Collections.<MavenProject>emptyList();\n        ctx = mock(MavenContext.class);\n\n        when(build.getDirectory()).thenReturn(tempDir.getAbsolutePath());\n        when(project.getBuild()).thenReturn(build);\n        when(ctx.getProject()).thenReturn(project);\n        when(ctx.getLog()).thenReturn(new SystemStreamLog());\n        when(ctx.getReactor()).thenReturn(reactor);\n        when(ctx.getSession()).thenReturn(null);\n        when(ctx.getPluginManager()).thenReturn(pluginManager);\n\n        goals = new MavenGoals(ctx);\n    }\n"
    },
    {
      "id": "example-92",
      "name": "Bug Example 92",
      "description": "Bug case from index 92",
      "buggy": "    public static void sell(final ItemStack itemStack, final Items item, Player player, final ItemStorageHolder region) {\n        player.getInventory().removeItem(itemStack);\n\n        ForeignCollection<PlayerOwns> playerList = region.getOwners();\n        boolean isOwner = false;\n\n        for(PlayerOwns player1 : playerList) {\n            if(player1.getPlayer().getName().equals(player.getName().toLowerCase())) {\n                isOwner = true;\n            }\n        }\n\n        if(isOwner) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_NotYourItem);\n            player.getInventory().setItemInHand(itemStack);\n            return;\n        }\n\n        if(item.getBuy() <= 0.0) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_DoesNotBuy);\n            player.getInventory().setItemInHand(itemStack);\n            return;\n        }\n\n        Group group = ConfigManager.groups.getGroup(region.getItemStorage().getSetting());\n        if(region.getItemStorage().getItemAmount() + itemStack.getAmount() >= group.Storage) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_FullStorage);\n            player.getInventory().setItemInHand(itemStack);\n\n            return;\n        }\n\n        Float price = (itemStack.getAmount() / item.getUnitAmount() ) * item.getBuy();\n\n        if (region.getItemStorage().isServershop() || VaultBridge.has(item.getOwner(), price)) {\n            String dataName = ItemName.getDataName(itemStack);\n            String niceItemName;\n            if(dataName.endsWith(\" \")) {\n                niceItemName = dataName + ItemName.nicer(itemStack.getType().toString());\n            }  else if(!dataName.equals(\"\")) {\n                niceItemName = dataName;\n            } else {\n                niceItemName = ItemName.nicer(itemStack.getType().toString());\n            }\n\n            if(!region.getItemStorage().isServershop()) {\n                OfflinePlayer owner = Plugin.getInstance().getServer().getOfflinePlayer(item.getOwner());\n\n                if (owner != null) {\n                    TransactionRepository.generateTransaction(owner,\n                            Transaction.TransactionType.BUY,\n                            region.getName(),\n                            player.getWorld().getName(),\n                            player.getName(),\n                            item.getMeta().getItemID(),\n                            itemStack.getAmount(),\n                            item.getBuy().doubleValue(),\n                            0.0,\n                            item.getUnitAmount());\n                }\n\n                VaultBridge.withdrawPlayer(item.getOwner(), price);\n            }\n\n            VaultBridge.depositPlayer(player.getName(), price);\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_PlayerHint.\n                    replace(\"%player\", player.getDisplayName()).\n                    replace(\"%amount\", ((Integer) itemStack.getAmount()).toString()).\n                    replace(\"%item\", niceItemName).\n                    replace(\"%shop\", region.getName()).\n                    replace(\"%price\", price.toString().\n                    replace(\"%owner\", item.getOwner())));\n\n            item.setCurrentAmount(item.getCurrentAmount() + itemStack.getAmount());\n            item.setBought(item.getBought() + itemStack.getAmount());\n\n            ItemStorage itemStorage = region.getItemStorage();\n            itemStorage.setItemAmount(itemStorage.getItemAmount() + itemStack.getAmount());\n\n            try {\n                Database.getDAO(ItemStorage.class).update(itemStorage);\n                Database.getDAO(Items.class).update(item);\n            } catch (SQLException e) {\n                Logger.error(\"Could not update Items/ItemStorage\", e);\n            }\n\n            TransactionRepository.generateTransaction(player,\n                    Transaction.TransactionType.SELL,\n                    region.getName(),\n                    player.getWorld().getName(),\n                    item.getOwner(),\n                    item.getMeta().getItemID(),\n                    itemStack.getAmount(),\n                    0.0,\n                    item.getBuy().doubleValue(),\n                    item.getUnitAmount());\n\n        } else {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_OwnerHasNotEnoughMoney);\n            player.getInventory().setItemInHand(itemStack);\n        }\n    }\n",
      "fixed": "    public static void sell(final ItemStack itemStack, final Items item, Player player, final ItemStorageHolder region) {\n        player.getInventory().removeItem(itemStack);\n\n        ForeignCollection<PlayerOwns> playerList = region.getOwners();\n        boolean isOwner = false;\n\n        for(PlayerOwns player1 : playerList) {\n            if(player1.getPlayer().getName().equals(player.getName().toLowerCase())) {\n                isOwner = true;\n            }\n        }\n\n        if(isOwner) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_NotYourItem);\n            player.getInventory().setItemInHand(itemStack);\n            return;\n        }\n\n        if(item.getBuy() <= 0.0) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_DoesNotBuy);\n            player.getInventory().setItemInHand(itemStack);\n            return;\n        }\n\n        Group group = ConfigManager.groups.getGroup(region.getItemStorage().getSetting());\n        if(region.getItemStorage().getItemAmount() + itemStack.getAmount() >= group.Storage) {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_FullStorage);\n            player.getInventory().setItemInHand(itemStack);\n\n            return;\n        }\n\n        Float price = (itemStack.getAmount() / item.getUnitAmount() ) * item.getBuy();\n\n        if (region.getItemStorage().isServershop() || VaultBridge.has(item.getOwner(), price)) {\n            String dataName = ItemName.getDataName(itemStack);\n            String niceItemName;\n            if(dataName.endsWith(\" \")) {\n                niceItemName = dataName + ItemName.nicer(itemStack.getType().toString());\n            }  else if(!dataName.equals(\"\")) {\n                niceItemName = dataName;\n            } else {\n                niceItemName = ItemName.nicer(itemStack.getType().toString());\n            }\n\n            if(!region.getItemStorage().isServershop()) {\n                OfflinePlayer owner = Plugin.getInstance().getServer().getOfflinePlayer(item.getOwner());\n\n                if (owner != null) {\n                    TransactionRepository.generateTransaction(owner,\n                            Transaction.TransactionType.BUY,\n                            region.getName(),\n                            player.getWorld().getName(),\n                            player.getName(),\n                            item.getMeta().getItemID(),\n                            itemStack.getAmount(),\n                            item.getBuy().doubleValue(),\n                            0.0,\n                            item.getUnitAmount());\n                }\n\n                VaultBridge.withdrawPlayer(item.getOwner(), price);\n            }\n\n            VaultBridge.depositPlayer(player.getName(), price);\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_PlayerHint.\n                    replace(\"%player\", player.getDisplayName()).\n                    replace(\"%amount\", ((Integer) itemStack.getAmount()).toString()).\n                    replace(\"%item\", niceItemName).\n                    replace(\"%shop\", region.getName()).\n                    replace(\"%price\", price.toString()).\n                    replace(\"%owner\", item.getOwner()));\n\n            item.setCurrentAmount(item.getCurrentAmount() + itemStack.getAmount());\n            item.setBought(item.getBought() + itemStack.getAmount());\n\n            ItemStorage itemStorage = region.getItemStorage();\n            itemStorage.setItemAmount(itemStorage.getItemAmount() + itemStack.getAmount());\n\n            try {\n                Database.getDAO(ItemStorage.class).update(itemStorage);\n                Database.getDAO(Items.class).update(item);\n            } catch (SQLException e) {\n                Logger.error(\"Could not update Items/ItemStorage\", e);\n            }\n\n            TransactionRepository.generateTransaction(player,\n                    Transaction.TransactionType.SELL,\n                    region.getName(),\n                    player.getWorld().getName(),\n                    item.getOwner(),\n                    item.getMeta().getItemID(),\n                    itemStack.getAmount(),\n                    0.0,\n                    item.getBuy().doubleValue(),\n                    item.getUnitAmount());\n\n        } else {\n            player.sendMessage(ConfigManager.main.Chat_prefix + ConfigManager.language.Sell_OwnerHasNotEnoughMoney);\n            player.getInventory().setItemInHand(itemStack);\n        }\n    }\n"
    },
    {
      "id": "example-179",
      "name": "Bug Example 179",
      "description": "Bug case from index 179",
      "buggy": "\tpublic static void configParse(Arena arena, Config cfg) {\n\t\tcfg.load();\n\t\tYamlConfiguration config = cfg.getYamlConfiguration();\n\n\t\tif (cfg.getString(CFG.GENERAL_TYPE, \"null\") != null && !cfg.getString(CFG.GENERAL_TYPE, \"null\").equals(\"null\")) {\n\t\t\t// opening existing arena\n\t\t\tarena.setFree(cfg.getString(CFG.GENERAL_TYPE).equals(\"free\"));\n\t\t\t\n\t\t\tif (cfg.getUnsafe(CFG.MODULES_STANDARDSPECTATE_ACTIVE.getNode()) == null) {\n\t\t\t\tcfg.createDefaults();\n\t\t\t}\n\t\t\t\n\t\t\tList<String> list = cfg.getStringList(CFG.LISTS_GOALS.getNode(), new ArrayList<String>());\n\t\t\tfor (String type : list) {\n\t\t\t\tArenaGoal aType = PVPArena.instance.getAgm().getType(type);\n\t\t\t\taType = aType.clone();\n\t\t\t\taType.setArena(arena);\n\t\t\t\tarena.goalAdd(aType);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tcfg.createDefaults();\n\t\t}\n\n\t\tif (config.get(\"classitems\") == null) {\n\t\t\tif (PVPArena.instance.getConfig().get(\"classitems\") != null) {\n\t\t\t\tfor (String key : PVPArena.instance.getConfig().getKeys(false)) {\n\t\t\t\t\tconfig.addDefault(\"classitems.\"+key, PVPArena.instance.getConfig().get(\"classitems.\"+key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconfig.addDefault(\"classitems.Ranger\", \"261,262:64,298,299,300,301\");\n\t\t\t\tconfig.addDefault(\"classitems.Swordsman\", \"276,306,307,308,309\");\n\t\t\t\tconfig.addDefault(\"classitems.Tank\", \"272,310,311,312,313\");\n\t\t\t\tconfig.addDefault(\"classitems.Pyro\", \"259,46:3,298,299,300,301\");\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tconfig.addDefault(\"tp.win\", \"old\");\n\t\tconfig.addDefault(\"tp.lose\", \"old\");\n\t\tconfig.addDefault(\"tp.exit\", \"exit\");\n\t\tconfig.addDefault(\"tp.death\", \"spectator\");\n\n\t\tconfig.addDefault(\"setup.wand\", Integer.valueOf(280));\n\n\t\tconfig.addDefault(\"game.allowDrops\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.dropSpawn\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.lives\", Integer.valueOf(3));\n\t\tconfig.addDefault(\"game.preventDeath\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.teamKill\", Boolean.valueOf(arena.isFreeForAll()));\n\t\tconfig.addDefault(\"game.refillInventory\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.weaponDamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.mustbesafe\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.woolFlagHead\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"messages.language\", \"en\");\n\t\tconfig.addDefault(\"messages.chat\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"messages.defaultChat\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"messages.onlyChat\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"general.classperms\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.enabled\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"general.restoreChests\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.signs\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"general.type\", arena.isFreeForAll()?\"free\":\"team\");\n\t\tconfig.addDefault(\"general.item-rewards\", \"none\");\n\t\tconfig.addDefault(\"general.random-reward\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.prefix\", \"PVP Arena\");\n\t\tconfig.addDefault(\"general.cmdfailjoin\", Boolean.valueOf(true));\n\n\t\tconfig.addDefault(\"region.spawncampdamage\", Integer.valueOf(1));\n\t\tconfig.addDefault(\"region.timer\", Integer.valueOf(20));\n\t\t\n\t\tconfig.addDefault(\"join.explicitPermission\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.manual\", Boolean.valueOf(!arena.isFreeForAll()));\n\t\tconfig.addDefault(\"join.random\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"join.onCountdown\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.forceeven\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.inbattle\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.range\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"join.warmup\", Integer.valueOf(0));\n\t\t\n\t\tconfig.addDefault(\"arenatype.randomSpawn\", arena.isFreeForAll());\n\t\tconfig.addDefault(\"goal.timed\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"goal.endtimer\", Integer.valueOf(20));\n\n\t\tconfig.addDefault(\"periphery.checkRegions\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"protection.spawn\", Integer.valueOf(3));\n\t\tconfig.addDefault(\"protection.restore\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.enabled\", Boolean.valueOf(true));\n\t\t\n\t\tconfig.addDefault(\"protection.blockplace\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.blockdamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.blocktntdamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.decay\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.drop\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.fade\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.form\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.fluids\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.firespread\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.grow\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.lavafirespread\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.lighter\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.painting\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.piston\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.punish\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.tnt\", Boolean.valueOf(true));\n\t\t\n\t\tconfig.addDefault(\"protection.checkExit\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.checkSpectator\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.checkLounges\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.inventory\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"delays.giveitems\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.inventorysave\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.inventoryprepare\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.playerdestroy\", Integer.valueOf(0));\n\n\t\tconfig.addDefault(\"start.countdown\", Integer.valueOf(5));\n\t\tconfig.addDefault(\"start.health\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.foodLevel\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.saturation\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.exhaustion\", Float.valueOf(0));\n\n\t\tconfig.addDefault(\"ready.startRatio\", Float.valueOf((float) 0.5));\n\t\tconfig.addDefault(\"ready.block\", \"IRON_BLOCK\");\n\t\tconfig.addDefault(\"ready.checkEach\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"ready.checkEachTeam\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"ready.min\", Integer.valueOf(2));\n\t\tconfig.addDefault(\"ready.max\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"ready.minTeam\", Integer.valueOf(1));\n\t\tconfig.addDefault(\"ready.maxTeam\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"ready.autoclass\", \"none\");\n\t\tconfig.addDefault(\"ready.startRatio\", Float.valueOf((float) 0.5));\n\n\t\tconfig.addDefault(\"lang.youjoin\", \"Welcome to the Arena!\");\n\t\tconfig.addDefault(\"lang.playerjoin\", \"Player %1% joined team %2%\");\n\t\t*/\n\t\tPVPArena.instance.getAgm().setDefaults(arena, config);\n\n\t\tconfig.options().copyDefaults(true);\n\n\t\tcfg.set(CFG.Z, \"0.9.0.65\");\n\t\tcfg.save();\n\t\tcfg.load();\n\n\t\tMap<String, Object> classes = config.getConfigurationSection(\n\t\t\t\t\"classitems\").getValues(false);\n\t\tarena.getClasses().clear();\n\t\tdb.i(\"reading class items\");\n\t\tfor (String className : classes.keySet()) {\n\t\t\tString s = \"\";\n\t\t\t\n\t\t\ttry {\n\t\t\t\ts = (String) classes.get(className);\n\t\t\t} catch (Exception e) {\n\t\t\t\tBukkit.getLogger().severe(\"[PVP Arena] Error while parsing class, skipping: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tItemStack[] items = new ItemStack[ss.length];\n\n\t\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\t\titems[i] = StringParser.getItemStackFromString(ss[i]);\n\t\t\t\tif (items[i] == null) {\n\t\t\t\t\tdb.w(\"unrecognized item: \" + items[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarena.addClass(className, items);\n\t\t\tdb.i(\"adding class items to class \" + className);\n\t\t}\n\t\tarena.addClass(\"custom\", StringParser.getItemStacksFromString(\"0\"));\n\t\tarena.setOwner(cfg.getString(CFG.GENERAL_OWNER));\n\t\tarena.setLocked(cfg.getString(CFG.GENERAL_ENABLED).equalsIgnoreCase(\"false\"));\n\t\tif (config.getConfigurationSection(\"arenaregion\") != null) {\n\t\t\tMap<String, Object> regs = config\n\t\t\t\t\t.getConfigurationSection(\"arenaregion\").getValues(false);\n\t\t\tfor (String rName : regs.keySet()) {\n\t\t\t\tArenaRegionShape region = Config.parseRegion(arena, config, rName);\n\t\t\t\t\n\t\t\t\tif (region == null) {\n\t\t\t\t\tPVPArena.instance.getLogger().severe(\"Error while loading arena, region null: \" + rName);\n\t\t\t\t} else if (region.getWorld() == null) {\n\t\t\t\t\tPVPArena.instance.getLogger().severe(\"Error while loading arena, world null: \" + rName);\n\t\t\t\t} else {\n\t\t\t\t\tarena.getRegions().add(region);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tarena.setRoundMap(null);\n\n\t\tcfg.save();\n\n\t\tPVPArena.instance.getAgm().configParse(arena, config);\n\t\tPVPArena.instance.getAmm().configParse(arena, config);\n\t\t\n\t\tif (cfg.getYamlConfiguration().getConfigurationSection(\"teams\") == null) {\n\t\t\tif (arena.isFreeForAll()) {\n\t\t\t\tconfig.set(\"teams.free\", \"WHITE\");\n\t\t\t} else {\n\t\t\t\tconfig.set(\"teams.red\", \"RED\");\n\t\t\t\tconfig.set(\"teams.blue\", \"BLUE\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tcfg.reloadMaps();\n\n\t\t\n\t\tMap<String, Object> tempMap = (Map<String, Object>) cfg\n\t\t\t\t.getYamlConfiguration().getConfigurationSection(\"teams\")\n\t\t\t\t.getValues(true);\n\n\t\tif (arena.isFreeForAll()) {\n\t\t\tarena.getTeams().add(new ArenaTeam(\"free\", \"WHITE\"));\n\t\t\tarena.getArenaConfig().set(CFG.PERMS_TEAMKILL, true);\n\t\t\tarena.getArenaConfig().save();\n\t\t} else {\n\t\t\tfor (String sTeam : tempMap.keySet()) {\n\t\t\t\tArenaTeam team = new ArenaTeam(sTeam, (String) tempMap.get(sTeam));\n\t\t\t\tarena.getTeams().add(team);\n\t\t\t\tdb.i(\"added team \" + team.getName() + \" => \"\n\t\t\t\t\t\t+ team.getColorCodeString());\n\t\t\t}\n\t\t}\n\n\t\tarena.setPrefix(cfg.getString(CFG.GENERAL_PREFIX));\n\t}\n",
      "fixed": "\tpublic static void configParse(Arena arena, Config cfg) {\n\t\tcfg.load();\n\t\tYamlConfiguration config = cfg.getYamlConfiguration();\n\n\t\tif (cfg.getString(CFG.GENERAL_TYPE, \"null\") != null && !cfg.getString(CFG.GENERAL_TYPE, \"null\").equals(\"null\")) {\n\t\t\t// opening existing arena\n\t\t\tarena.setFree(cfg.getString(CFG.GENERAL_TYPE).equals(\"free\"));\n\t\t\t\n\t\t\tif (cfg.getUnsafe(CFG.MODULES_STANDARDSPECTATE_ACTIVE.getNode()) == null) {\n\t\t\t\tcfg.createDefaults();\n\t\t\t}\n\t\t\t\n\t\t\tList<String> list = cfg.getStringList(CFG.LISTS_GOALS.getNode(), new ArrayList<String>());\n\t\t\tfor (String type : list) {\n\t\t\t\tArenaGoal aType = PVPArena.instance.getAgm().getType(type);\n\t\t\t\taType = aType.clone();\n\t\t\t\taType.setArena(arena);\n\t\t\t\tarena.goalAdd(aType);\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tcfg.createDefaults();\n\t\t}\n\n\t\tif (config.get(\"classitems\") == null) {\n\t\t\tif (PVPArena.instance.getConfig().get(\"classitems\") != null) {\n\t\t\t\tfor (String key : PVPArena.instance.getConfig().getKeys(false)) {\n\t\t\t\t\tconfig.addDefault(\"classitems.\"+key, PVPArena.instance.getConfig().get(\"classitems.\"+key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconfig.addDefault(\"classitems.Ranger\", \"261,262:64,298,299,300,301\");\n\t\t\t\tconfig.addDefault(\"classitems.Swordsman\", \"276,306,307,308,309\");\n\t\t\t\tconfig.addDefault(\"classitems.Tank\", \"272,310,311,312,313\");\n\t\t\t\tconfig.addDefault(\"classitems.Pyro\", \"259,46:3,298,299,300,301\");\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tconfig.addDefault(\"tp.win\", \"old\");\n\t\tconfig.addDefault(\"tp.lose\", \"old\");\n\t\tconfig.addDefault(\"tp.exit\", \"exit\");\n\t\tconfig.addDefault(\"tp.death\", \"spectator\");\n\n\t\tconfig.addDefault(\"setup.wand\", Integer.valueOf(280));\n\n\t\tconfig.addDefault(\"game.allowDrops\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.dropSpawn\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.lives\", Integer.valueOf(3));\n\t\tconfig.addDefault(\"game.preventDeath\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.teamKill\", Boolean.valueOf(arena.isFreeForAll()));\n\t\tconfig.addDefault(\"game.refillInventory\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.weaponDamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"game.mustbesafe\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"game.woolFlagHead\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"messages.language\", \"en\");\n\t\tconfig.addDefault(\"messages.chat\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"messages.defaultChat\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"messages.onlyChat\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"general.classperms\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.enabled\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"general.restoreChests\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.signs\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"general.type\", arena.isFreeForAll()?\"free\":\"team\");\n\t\tconfig.addDefault(\"general.item-rewards\", \"none\");\n\t\tconfig.addDefault(\"general.random-reward\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"general.prefix\", \"PVP Arena\");\n\t\tconfig.addDefault(\"general.cmdfailjoin\", Boolean.valueOf(true));\n\n\t\tconfig.addDefault(\"region.spawncampdamage\", Integer.valueOf(1));\n\t\tconfig.addDefault(\"region.timer\", Integer.valueOf(20));\n\t\t\n\t\tconfig.addDefault(\"join.explicitPermission\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.manual\", Boolean.valueOf(!arena.isFreeForAll()));\n\t\tconfig.addDefault(\"join.random\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"join.onCountdown\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.forceeven\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.inbattle\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"join.range\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"join.warmup\", Integer.valueOf(0));\n\t\t\n\t\tconfig.addDefault(\"arenatype.randomSpawn\", arena.isFreeForAll());\n\t\tconfig.addDefault(\"goal.timed\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"goal.endtimer\", Integer.valueOf(20));\n\n\t\tconfig.addDefault(\"periphery.checkRegions\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"protection.spawn\", Integer.valueOf(3));\n\t\tconfig.addDefault(\"protection.restore\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.enabled\", Boolean.valueOf(true));\n\t\t\n\t\tconfig.addDefault(\"protection.blockplace\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.blockdamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.blocktntdamage\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.decay\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.drop\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.fade\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.form\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.fluids\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.firespread\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.grow\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.lavafirespread\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.lighter\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.painting\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.piston\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"protection.punish\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.tnt\", Boolean.valueOf(true));\n\t\t\n\t\tconfig.addDefault(\"protection.checkExit\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.checkSpectator\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.checkLounges\", Boolean.valueOf(false));\n\t\tconfig.addDefault(\"protection.inventory\", Boolean.valueOf(false));\n\n\t\tconfig.addDefault(\"delays.giveitems\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.inventorysave\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.inventoryprepare\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"delays.playerdestroy\", Integer.valueOf(0));\n\n\t\tconfig.addDefault(\"start.countdown\", Integer.valueOf(5));\n\t\tconfig.addDefault(\"start.health\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.foodLevel\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.saturation\", Integer.valueOf(20));\n\t\tconfig.addDefault(\"start.exhaustion\", Float.valueOf(0));\n\n\t\tconfig.addDefault(\"ready.startRatio\", Float.valueOf((float) 0.5));\n\t\tconfig.addDefault(\"ready.block\", \"IRON_BLOCK\");\n\t\tconfig.addDefault(\"ready.checkEach\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"ready.checkEachTeam\", Boolean.valueOf(true));\n\t\tconfig.addDefault(\"ready.min\", Integer.valueOf(2));\n\t\tconfig.addDefault(\"ready.max\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"ready.minTeam\", Integer.valueOf(1));\n\t\tconfig.addDefault(\"ready.maxTeam\", Integer.valueOf(0));\n\t\tconfig.addDefault(\"ready.autoclass\", \"none\");\n\t\tconfig.addDefault(\"ready.startRatio\", Float.valueOf((float) 0.5));\n\n\t\tconfig.addDefault(\"lang.youjoin\", \"Welcome to the Arena!\");\n\t\tconfig.addDefault(\"lang.playerjoin\", \"Player %1% joined team %2%\");\n\t\t*/\n\t\tPVPArena.instance.getAgm().setDefaults(arena, config);\n\n\t\tconfig.options().copyDefaults(true);\n\n\t\tcfg.set(CFG.Z, \"0.9.0.65\");\n\t\tcfg.save();\n\t\tcfg.load();\n\n\t\tMap<String, Object> classes = config.getConfigurationSection(\n\t\t\t\t\"classitems\").getValues(false);\n\t\tarena.getClasses().clear();\n\t\tdb.i(\"reading class items\");\n\t\tfor (String className : classes.keySet()) {\n\t\t\tString s = \"\";\n\t\t\t\n\t\t\ttry {\n\t\t\t\ts = (String) classes.get(className);\n\t\t\t} catch (Exception e) {\n\t\t\t\tBukkit.getLogger().severe(\"[PVP Arena] Error while parsing class, skipping: \" + className);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tString[] ss = s.split(\",\");\n\t\t\tItemStack[] items = new ItemStack[ss.length];\n\n\t\t\tfor (int i = 0; i < ss.length; i++) {\n\t\t\t\titems[i] = StringParser.getItemStackFromString(ss[i]);\n\t\t\t\tif (items[i] == null) {\n\t\t\t\t\tdb.w(\"unrecognized item: \" + items[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tarena.addClass(className, items);\n\t\t\tdb.i(\"adding class items to class \" + className);\n\t\t}\n\t\tarena.addClass(\"custom\", StringParser.getItemStacksFromString(\"0\"));\n\t\tarena.setOwner(cfg.getString(CFG.GENERAL_OWNER));\n\t\tarena.setLocked(!cfg.getBoolean(CFG.GENERAL_ENABLED));\n\t\tif (config.getConfigurationSection(\"arenaregion\") != null) {\n\t\t\tMap<String, Object> regs = config\n\t\t\t\t\t.getConfigurationSection(\"arenaregion\").getValues(false);\n\t\t\tfor (String rName : regs.keySet()) {\n\t\t\t\tArenaRegionShape region = Config.parseRegion(arena, config, rName);\n\t\t\t\t\n\t\t\t\tif (region == null) {\n\t\t\t\t\tPVPArena.instance.getLogger().severe(\"Error while loading arena, region null: \" + rName);\n\t\t\t\t} else if (region.getWorld() == null) {\n\t\t\t\t\tPVPArena.instance.getLogger().severe(\"Error while loading arena, world null: \" + rName);\n\t\t\t\t} else {\n\t\t\t\t\tarena.getRegions().add(region);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tarena.setRoundMap(null);\n\n\t\tcfg.save();\n\n\t\tPVPArena.instance.getAgm().configParse(arena, config);\n\t\tPVPArena.instance.getAmm().configParse(arena, config);\n\t\t\n\t\tif (cfg.getYamlConfiguration().getConfigurationSection(\"teams\") == null) {\n\t\t\tif (arena.isFreeForAll()) {\n\t\t\t\tconfig.set(\"teams.free\", \"WHITE\");\n\t\t\t} else {\n\t\t\t\tconfig.set(\"teams.red\", \"RED\");\n\t\t\t\tconfig.set(\"teams.blue\", \"BLUE\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tcfg.reloadMaps();\n\n\t\t\n\t\tMap<String, Object> tempMap = (Map<String, Object>) cfg\n\t\t\t\t.getYamlConfiguration().getConfigurationSection(\"teams\")\n\t\t\t\t.getValues(true);\n\n\t\tif (arena.isFreeForAll()) {\n\t\t\tarena.getTeams().add(new ArenaTeam(\"free\", \"WHITE\"));\n\t\t\tarena.getArenaConfig().set(CFG.PERMS_TEAMKILL, true);\n\t\t\tarena.getArenaConfig().save();\n\t\t} else {\n\t\t\tfor (String sTeam : tempMap.keySet()) {\n\t\t\t\tArenaTeam team = new ArenaTeam(sTeam, (String) tempMap.get(sTeam));\n\t\t\t\tarena.getTeams().add(team);\n\t\t\t\tdb.i(\"added team \" + team.getName() + \" => \"\n\t\t\t\t\t\t+ team.getColorCodeString());\n\t\t\t}\n\t\t}\n\n\t\tarena.setPrefix(cfg.getString(CFG.GENERAL_PREFIX));\n\t}\n"
    },
    {
      "id": "example-186",
      "name": "Bug Example 186",
      "description": "Bug case from index 186",
      "buggy": "        public Point2D getDimensionInPixel(Map<String,Value> map, double height,\n                    double width, Double scale, Double dpi) throws ParameterException {\n                double dx, dy;\n\n                double ratio = height / width;\n\n                if (x != null && y != null) {\n                        dx = x.getValue(map);\n                        dy = y.getValue(map);\n                } else if (x != null) {\n                        dx = x.getValue(map);\n                        dy = dx * ratio;\n                } else if (y != null) {\n                        dy = y.getValue(map);\n                        dx = dy / ratio;\n                } else { // nothing is defined\n                        dx = width;\n                        dy = height;\n                        //return null; \n                }\n\n\n                dx = Uom.toPixel(dx, ((UomNode)getParent()).getUom(), dpi, scale, width);\n                dy = Uom.toPixel(dy, ((UomNode)getParent()).getUom(), dpi, scale, height);\n\n                if (dx <= 0.00021 || dy <= 0.00021) {\n                        throw new ParameterException(\"View-box is too small: (\" + dx + \";\" + dy + \")\");\n                }\n\n                return new Point2D.Double(dx, dy);\n        }\n",
      "fixed": "        public Point2D getDimensionInPixel(Map<String,Value> map, double height,\n                    double width, Double scale, Double dpi) throws ParameterException {\n                double dx, dy;\n\n                double ratio = height / width;\n\n                if (x != null && y != null) {\n                        dx = x.getValue(map);\n                        dy = y.getValue(map);\n                } else if (x != null) {\n                        dx = x.getValue(map);\n                        dy = dx * ratio;\n                } else if (y != null) {\n                        dy = y.getValue(map);\n                        dx = dy / ratio;\n                } else { // nothing is defined\n                        dx = width;\n                        dy = height;\n                        //return null; \n                }\n\n\n                dx = Uom.toPixel(dx, ((UomNode)getParent()).getUom(), dpi, scale, width);\n                dy = Uom.toPixel(dy, ((UomNode)getParent()).getUom(), dpi, scale, height);\n\n                if (dx <= 0.00021 || dy <= 0.00021) {\n                        dx=0;\n                        dy=0;\n                }\n\n                return new Point2D.Double(dx, dy);\n        }\n"
    },
    {
      "id": "example-839",
      "name": "Bug Example 839",
      "description": "Bug case from index 839",
      "buggy": "  void readit(InputStream is, String map, String params) \n                              throws IOException, VisADException {\n    // read the ASCII file, using commas as field separators\n    // first line is a header line\n\n    ff = null;\n    field = null;\n\n    if (debug) System.out.println(\"####   Text Adapter v2.x running\");\n\n    BufferedReader bis = new BufferedReader(new InputStreamReader(is));\n\n    // mapping defines how the names are mapped\n    // for example:   (x,y) => (one, two, three)\n\n    String maps = null;\n    if (map == null) {\n      maps = readLine(bis);\n      if(maps != null) {\n          maps = maps.trim();\n      }\n    } else {\n      maps = map;\n    }\n\n    if (maps != null) {\n       maps = makeMT(maps);\n    }\n    if (maps == null) {\n      throw new visad.data.BadFormException(\n        \"TextAdapter: Invalid or missing MathType\");\n    }\n\n    if (debug) System.out.println(\"Specified MathType = \"+maps);\n\n    // but first, we need to get the column headers because they\n    // may have [units] associated with them.  The column headers\n    // primarily define where the data are.\n\n    String hdr = null;\n    if (params == null) {\n      hdr = readLine(bis);\n    } else {\n      hdr = params;\n    }\n\n    String hdrDelim = DELIM;\n    if (DELIM == null) {\n      if (hdr.indexOf(BLANK) != -1) hdrDelim = BLANK_DELIM; \n      if (hdr.indexOf(COMMA) != -1) hdrDelim = COMMA; \n      if (hdr.indexOf(SEMICOLON) != -1) hdrDelim = SEMICOLON; \n      if (hdr.indexOf(TAB) != -1) hdrDelim = TAB; \n\n      if (debug) System.out.println(\"Using header delimiter = \"+\n                                     (hdrDelim.getBytes())[0]);\n    }\n\n    String[] sthdr = hdr.split(hdrDelim);\n    int nhdr = sthdr.length;\n    infos    = new HeaderInfo[nhdr];\n    for(int i=0;i<infos.length;i++) {\n      infos[i] = new HeaderInfo();\n    }\n    Real[] prototypeReals = new Real[nhdr];\n    hdrColumns = new int[2][nhdr];\n    int numHdrValues=0;\n\n    // pre-scan of the header names to seek out Units\n    // since we cannot change a RealType once it's defined!!\n\n    for (int i=0; i<nhdr; i++) {\n      String name = sthdr[i].trim();\n      String hdrUnitString = null;\n      hdrColumns[0][i] = -1; // indicating no fixed columns\n      \n      int m = name.indexOf(\"[\");\n\n      if (m == -1) {\n          infos[i].name = name;\n          hdrUnitString = null;\n      } else {\n        int m2 = name.indexOf(\"]\");\n        if (m2 == -1) {\n          throw new VisADException(\"TextAdapter: Bad [descriptor] named in:\"+name);\n        }\n\n        // now parse items: unit=xxx miss=xxx interval=xxx error=xxx\n\n        // 1. tokenize on \" \"\n        // 2. scan each token, retokenizing on \"=\"\n        // 3. if (has no \"=\") && (is first one) then treat as Unit\n        // 4. otherwise, look for keys \"unit\" \"miss\" \"inter\" \"err\" \"scale\" \"offset\" \"pos\"\n      \n        //    and fill in the values in array[i]\n\n        if (m2 >= name.length()) {\n          infos[i].name = name.substring(0,m).trim();\n        } else {\n          infos[i].name = (name.substring(0,m)+name.substring(m2+1)).trim();\n        }\n\n        String cl = name.substring(m+1,m2).trim();\n        String[] stcl = cl.split(BLANK_DELIM);\n        int ncl = stcl.length;\n\n        if (ncl == 1 && cl.indexOf(\"=\") == -1) {\n          hdrUnitString = cl;  // backward compatible...\n\n        } else {\n          for (int l = 0; l  < ncl; l++) {\n            String s = stcl[l++];\n            String[] sts = s.split(\"=\");\n            if (sts.length != 2) {\n              throw new VisADException(\"TextAdapter: Invalid clause in: \"+s);\n            }\n            String tok = sts[0];\n            String val = sts[1];\n            \n            // check for quoted strings\n            if (val.startsWith(\"\\\"\")) {\n\n              // see if ending quote also fetched\n              if (val.endsWith(\"\\\"\")) {\n                String v2 = val.substring(1,val.length()-1);\n                val = v2;\n\n              } else {\n                // if not, then reparse stcl to suck up spaces...\n                try {\n                  String v2=\"\";\n                  for (int q=l; q < ncl; q++) {\n                      String  vTmp = stcl[q];\n                      // find next token that has a \" in it\n                      int pos = vTmp.indexOf(\"\\\"\");\n                      if (pos < 0) {  // no \"\n                          v2 = v2+\" \"+vTmp;\n                          l++;\n                      } else {\n                          v2 = v2+\" \"+vTmp.substring(0,pos);\n                          stcl[l] = vTmp.substring(pos+1);\n                          break;\n                      }\n                  }\n                  String v3 = val.substring(1)+v2;\n                  val = v3;\n\n                //} catch (NoSuchElementException nse2) {\n                } catch (ArrayIndexOutOfBoundsException nse2) {\n                  val=\"\";\n                }\n              }\n            }\n\n            if (debug) System.out.println(\"####   tok = \"+tok+ \" val = '\"+val+\"'\");\n\n            if (tok.toLowerCase().startsWith(ATTR_UNIT)) {\n              hdrUnitString = val;\n\n            } else if (tok.toLowerCase().startsWith(ATTR_MISSING)) {\n                infos[i].missingString = val.trim();\n              try {\n                infos[i].missingValue = Double.parseDouble(val);\n              } catch (java.lang.NumberFormatException me) {\n                  infos[i].missingValue = Double.NaN;\n              }\n            } else if (tok.toLowerCase().startsWith(ATTR_INTERVAL)) {\n              infos[i].isInterval = -1;\n              if (val.toLowerCase().startsWith(\"t\")) infos[i].isInterval = 1;\n              if (val.toLowerCase().startsWith(\"f\")) infos[i].isInterval = 0;\n              if (infos[i].isInterval == -1) {\n                throw new VisADException(\"TextAdapter: Value of \\'interval\\' must be \\'true\\' or \\'false\\'\");\n              }\n            } else if (tok.toLowerCase().startsWith(ATTR_ERROR)) {\n                infos[i].errorEstimate = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_SCALE)) {\n                infos[i].scale = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_OFFSET)) {\n              infos[i].offset = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_VALUE)) {\n              infos[i].fixedValue = val.trim();\n              numHdrValues++;\n            } else if (tok.toLowerCase().startsWith(ATTR_COLSPAN)) {\n              infos[i].colspan = (int)Double.parseDouble(val.trim());\n            } else if (tok.toLowerCase().startsWith(ATTR_POSITION)) {\n              String[] stp = val.split(\":\");\n              if (stp.length != 2) {\n                throw new VisADException(\"TextAdapter: invalid Position parameter in:\"+s);\n              }\n              hdrColumns[0][i] = Integer.parseInt(stp[0].trim());\n              hdrColumns[1][i] = Integer.parseInt(stp[1].trim());\n\n            } else if (tok.toLowerCase().startsWith(ATTR_FORMAT)) {\n                infos[i].formatString = val.trim();\n            } else if (tok.toLowerCase().startsWith(ATTR_TIMEZONE)) {\n                infos[i].tzString = val.trim();\n            } else {\n              throw new VisADException(\"TextAdapter: invalid token name: \"+s);\n            }\n\n          }\n        }\n\n      }\n\n\n      if (debug) \n            System.out.println(\"hdr name = \"+infos[i]+\" units=\"+\n             hdrUnitString+\n             \" miss=\"+infos[i].missingValue+\" interval=\"+infos[i].isInterval+ \n             \" errorest=\"+infos[i].errorEstimate+\" scale=\"+infos[i].scale+\n             \" offset=\"+infos[i].offset+\" pos=\"+hdrColumns[0][i]+\":\"+\n             hdrColumns[1][i]);\n\n      Unit u = null;\n      if (hdrUnitString != null && \n                !hdrUnitString.trim().equalsIgnoreCase(\"null\") ) {\n        try {\n\n          u = visad.data.units.Parser.parse(hdrUnitString.trim());\n        } catch (Exception ue) {\n\n          try {\n            u = visad.data.units.Parser.parse(\n                           hdrUnitString.trim().replace(' ','_'));\n          } catch (Exception ue2) {\n            System.out.println(\"Unit name problem:\"+ue+\" with: \"+hdrUnitString);\n            u = null;\n          }\n        }\n      }\n\n      if (debug) System.out.println(\"####   assigned Unit as u=\"+u);\n\n\n      String rttemp = infos[i].name.trim();\n      if (rttemp.indexOf(\"(Text)\") == -1) {\n\n        int parenIndex = rttemp.indexOf(\"(\");\n\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\"[\");\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\"{\");\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\" \");\n        String rtname = parenIndex < 0 ? rttemp.trim() : rttemp.substring(0,parenIndex);\n\n\n        RealType rt = RealType.getRealType(rtname, u, null, infos[i].isInterval);\n\n        if (rt == null) {  // tried to re-use with different units\n          if (debug) System.out.println(\"####   rt was returned as null\");\n          if (u != null) System.out.println(\"####  Could not make RealType using specified Unit (\"+hdrUnitString+\") for parameter name: \"+rtname);\n          rt = RealType.getRealType(rtname);\n        }\n\n        // get a compatible unit, if necessary\n\n        if (rt.equals(visad.RealType.Time)) {\n          GOTTIME = true;\n          if (debug) System.out.println(\"####  found a visad.RealType.Time component\");\n        } else {\n          GOTTIME = false;\n        }\n\n\n        if (u == null) u = rt.getDefaultUnit();\n        if(debug) System.out.println(\"####  retrieve units from RealType = \"+u);\n      }\n\n      infos[i].unit = u;\n    }\n\n    // get the MathType of the function\n\n    MathType mt = null;\n    try {\n      mt = MathType.stringToType(maps);\n    } catch (Exception mte) {\n      System.out.println(\"####  Exception: \"+mte);\n      throw new VisADException(\"TextAdapter: MathType badly formed or missing: \"+maps);\n    }\n\n    if (debug) {\n      System.out.println(mt);\n      new visad.jmet.DumpType().dumpMathType(mt,System.out);\n    }\n\n    // now get the names of the domain variables and range variables.\n    String[] domainNames = null;\n    String[] rangeNames = null;\n    int numDom = 0;\n    int numRng = 0;\n    RealTupleType domType;\n    TupleType rngType;\n\n    if (mt instanceof FunctionType) {\n      domType = ((FunctionType)mt).getDomain();\n      numDom = domType.getDimension();\n      domainNames = new String[numDom];\n\n      for (int i=0; i<numDom; i++) {\n        MathType comp = domType.getComponent(i);\n        domainNames[i] = ((RealType)comp).toString().trim();\n        if (debug) System.out.println(\"dom \"+i+\" = \"+domainNames[i]);\n      }\n\n      rngType = (TupleType) ((FunctionType)mt).getRange();\n      numRng = rngType.getDimension();\n      rangeNames = new String[numRng];\n      rangeSets = new Set[numRng];\n      for (int i=0; i<numRng; i++) {\n        MathType comp = rngType.getComponent(i);\n        rangeNames[i] = (comp).toString().trim();\n        if (debug) System.out.println(\"range \"+i+\" = \"+rangeNames[i]);\n        if (comp instanceof RealType) {\n          rangeSets[i] = ((RealType) comp).getDefaultSet();\n          if (rangeSets[i] == null) {\n            if (comp.equals(RealType.Time)) {\n              rangeSets[i] = new DoubleSet(new SetType(comp));\n            } else {\n              rangeSets[i] = new FloatSet(new SetType(comp));\n            }\n          }\n        } else {\n          rangeSets[i] = null;  // something else is wrong here...\n        }\n        if (debug) System.out.println(\"####  rangeSet = \"+rangeSets[i]);\n;\n      }\n\n    } else { \n      throw new visad.VisADException(\"TextAdapter: Math Type is not a simple FunctionType\");\n    }\n\n\n// now for each header label, determine if it's a domain or\n// range component -- and if so, which one.\n\n// also, if it's a domain component, allow for name(first:last[:number])\n//\n// and if none of the domain components appear in the list, then\n// they are computed as name(0:N-1)\n\n    int[] domainPointer = new int[numDom];\n    double[][] domainRanges = new double[3][numDom]; // min, max, numb\n    boolean[] gotDomainRanges = new boolean[numDom];\n    domainErrorEstimates = new double[numDom];\n    domainUnits = new Unit[numDom];\n    rangeErrorEstimates = new double[numRng];\n    rangeUnits = new Unit[numRng];\n\n    int countDomain = 0;\n\n    for (int i=0; i<numDom; i++) {\n      domainPointer[i] = -1;\n      gotDomainRanges[i] = false;\n      domainErrorEstimates[i] = Double.NaN;\n      domainUnits[i] = null;\n    }\n\n    int[] rangePointer = new int[numRng];\n    int countRange = 0;\n\n    for (int i=0; i<numRng; i++) {\n      rangePointer[i] = -1;\n      rangeErrorEstimates[i] = Double.NaN;\n      rangeUnits[i] = null;\n    }\n\n    int countValues = -1;\n    values_to_index = new int[3][nhdr];\n\n    for (int i=0; i<nhdr; i++) {\n      values_to_index[0][i] = -1;  // points to domains\n      values_to_index[1][i] = -1;  // points to ranges\n      values_to_index[2][i] = -1;  // points to names/units/etc\n      countValues ++;\n\n      String name = infos[i].name;\n\n\n      // see if it's a domain name\n      boolean gotName = false;\n\n      // is there a \"min:max\" clause?\n      String test_name = name;\n      int n = test_name.indexOf(\"(\");\n      if (n != -1) {\n        // but allow for \"(Text)\" \n        if ((test_name.indexOf(\"(Text)\")) == -1) {\n          test_name = name.substring(0,n).trim();\n          countValues --;  // this value wont appear in data!\n          countDomain --; // and is a pre-defined, linear set\n        }\n      }\n\n      // try to find the column header name in the domain name list\n      for (int k=0; k<numDom; k++) {\n\n        if (test_name.equals(domainNames[k]) ) { \n          domainPointer[k] = countValues;\n          domainErrorEstimates[k] = infos[i].errorEstimate;\n          domainUnits[k] = infos[i].unit;\n          gotName = true;\n          countDomain ++;\n          // now see if a list is given...\n          if (n != -1) {\n\n            try {\n\n              String ss = name.substring(n+1,name.length()-1);\n              String[] sct = ss.split(\":\");\n              String first = sct[0].trim();\n              String second = sct[1].trim();\n              String third = \"1\";\n              if (sct.length == 3) third = sct[2].trim();\n              domainRanges[0][k] = Double.parseDouble(first);\n              domainRanges[1][k] = Double.parseDouble(second);\n              domainRanges[2][k] = Double.parseDouble(third);\n              gotDomainRanges[k] = true;\n\n            } catch (Exception ef) {\n              throw new VisADException(\n       \"TextAdapter: Error while interpreting min:max values for domain \"+name);\n            }\n\n          } else if (countValues > -1) { // if no list, get from file\n            values_to_index[0][countValues] = k;\n            values_to_index[2][countValues] = i;\n          }\n\n          break;\n       }\n\n    } \n\n    if (gotName) continue;\n\n    // or see if its a range name...\n\n    for (int k=0; k<numRng; k++) {\n      if (name.equals(rangeNames[k]) ) {\n        rangePointer[k] = countValues;\n        rangeErrorEstimates[k] = infos[i].errorEstimate;\n        rangeUnits[k] = infos[i].unit;\n        countRange ++;\n        values_to_index[1][countValues] = k;\n        values_to_index[2][countValues] = i;\n        gotName = true;\n      }\n    }\n  }\n\n\n// huge debug printout...\n// *****************************************************************\n\n  if (debug) {\n    System.out.println(\"countDom/numDom=\"+countDomain+\" \"+numDom);\n\n    System.out.println(\"countRange/numRng=\"+countRange+\" \"+numRng);\n\n    System.out.println(\"Domain info:\");\n    for (int i=0; i<numDom; i++) {\n      System.out.println(\"Dom name / index = \"+domainNames[i]+\"  \"+\n             domainPointer[i]);\n\n      if (gotDomainRanges[i]) {\n        System.out.println(\"    ...\"+domainRanges[0][i]+\"  \"+\n            domainRanges[1][i]+\"    \"+domainRanges[2][i]);\n      }\n    }\n\n    System.out.println(\"Range info:\");\n    for (int i=0; i<numRng; i++) {\n      System.out.println(\"Rng name / index / error est = \"+rangeNames[i]+\"  \"+\n             rangePointer[i]+ \"  \" + rangeErrorEstimates[i] +\" \"+\n             rangeUnits[i]);\n    }\n\n    System.out.println(\"values_to_index pointers = \");\n    for (int i=0; i<nhdr; i++) {\n      System.out.println(\" inx / value = \"+i+ \n              \" \"+values_to_index[0][i]+\"    \"+values_to_index[1][i]+\n              \" \"+values_to_index[2][i]);\n    }\n  }\n\n// ***************************************************************\n\n\n    // for each line of text, put the values into the ArrayList\n    ArrayList domainValues = new ArrayList();\n    ArrayList rangeValues = new ArrayList();\n    ArrayList tupleValues = new ArrayList(); \n    boolean tryToMakeTuple = true;\n    Tuple tuple = null;\n    \n    String dataDelim = DELIM;\n    boolean isRaster = false;\n    int numElements = 1;\n\n    // in the 'raster array' case, the numRng value will be 1,\n    // along with the countRange.  numDomain must be 2.\n\n    // if the domain is 2D, then get values from the first\n    // matching column to the end...\n    if (countRange == 1 && numRng == 1 && \n                numDom == 2 && countDomain < 2) isRaster = true;\n\n    int index;\n    while (true) {\n      String s = bis.readLine();\n      if (debug) System.out.println(\"read:\"+s);\n      if (s == null) break;\n      if (!isText(s)) return;\n      if (isComment(s)) continue;\n      if (dataDelim == null) {\n        if (s.indexOf(BLANK) != -1) dataDelim = BLANK_DELIM; \n        if (s.indexOf(COMMA) != -1) dataDelim = COMMA; \n        if (s.indexOf(SEMICOLON) != -1) dataDelim = SEMICOLON; \n        if (s.indexOf(TAB) != -1) dataDelim = TAB; \n\n        if (debug) System.out.println(\"Using data delimiter = \"+\n                                       (dataDelim.getBytes())[0]);\n      }\n\n      \n      if((index=s.indexOf(\"=\"))>=0) {\n        String name  = s.substring(0,index).trim();\n        String value  = s.substring(index+1).trim();\n        boolean foundIt = false;\n        for(int paramIdx=0;paramIdx<infos.length;paramIdx++) {\n            if(infos[paramIdx].isParam(name)) {\n                if(infos[paramIdx].fixedValue==null) {\n                    numHdrValues++;\n                }\n                infos[paramIdx].fixedValue = value;\n                foundIt = true;\n                break;\n            }\n        }\n        if(!foundIt) {\n           throw new VisADException(\n                    \"TextAdapter: Cannot find field with name:\" +name +\" from line:\" + s);\n        }\n        continue;\n      }\n\n\n\n      String[] st = s.split(dataDelim);\n      int n = st.length;\n      if (n < 1) continue; // something is wrong if this happens!\n\n      double [] dValues = new double[numDom];\n      double [] rValues = null;\n      Data [] tValues = null;\n\n      if (isRaster) {\n\n        if (debug) System.out.println(\"probably a raster...\");\n        boolean gotFirst = false;\n        int rvaluePointer = 0;\n        int irange = 0;\n        for (int i=0; i<n; i++) {\n\n          String sa = st[i];\n          \n          if (i >= nhdr) {  // are we past where domain would be found?\n\n            if (!gotFirst) {\n              throw new VisADException(\n                        \"TextAdapter: Cannot find first raster value\");\n            }\n\n            rvaluePointer ++;\n            rValues[rvaluePointer] = getVal(sa, irange);\n\n          } else {  // or are we still looking for domain?\n          \n            if (values_to_index[0][i] != -1) {\n              dValues[values_to_index[0][i]] = getVal(sa, i);\n            }\n\n            if (gotFirst) {  // already gathering data\n              rvaluePointer ++;\n              rValues[rvaluePointer] = getVal(sa, irange);\n\n            } else {\n               if (values_to_index[1][i] != -1) {\n                 // cannot dimension the array until we have found\n                 // the first set of range values!!\n                 rValues = new double[n - i];\n                 irange = i;\n                 rValues[rvaluePointer] = getVal(sa, irange);\n                 gotFirst = true;\n               }\n            }\n\n          }\n        }\n         \n      } else {  // is probably NOT a raster\n\n        tValues = new Data[numRng];\n      \n        if (debug) System.out.println(\"probably not a raster...\");\n        rValues = new double[numRng];\n        double thisDouble; \n        MathType thisMT;\n        if (n > nhdr) n = nhdr; // in case the # tokens > # parameters\n        n +=numHdrValues;\n\n        int l = 0;   // token counter\n        for (int i=0; i<nhdr; i++) {   // loop over the columns\n          String sa;\n          if(infos[i].fixedValue!=null) {\n            sa = infos[i].fixedValue;\n          }  else if (l >= st.length) {   // more params than tokens\n            sa = \"\";                      // need to have a missing value\n          } else {\n            sa = st[l++].trim();\n            int moreColumns = infos[i].colspan-1;\n            while (moreColumns>0) {\n                sa = sa + \" \" + st[l++].trim();\n                moreColumns--;\n            }\n          }\n\n          String sThisText;\n\n          if (values_to_index[0][i] != -1) {\n            dValues[values_to_index[0][i]] = getVal(sa, i);\n          } else if (values_to_index[1][i] != -1) {\n\n            thisMT = rngType.getComponent(values_to_index[1][i]);\n            \n            if (thisMT instanceof TextType) {\n\n              // if Text, then check for quoted string\n              if (sa.startsWith(\"\\\"\")) {\n                if (sa.endsWith(\"\\\"\")) {  // if single token ends with quote\n                  String sa2 = sa.substring(1,sa.length()-1);\n                  sThisText = sa2;\n                } else {\n                  // TODO:  work on this\n                  try {\n                    String delim = \n                        dataDelim.equals(BLANK_DELIM) ? BLANK : dataDelim;\n                    String sa2=\"\";\n                    for (int q=l; q < st.length; q++) {\n                        String  saTmp = st[q];\n                        // find next token that has a \" in it\n                        int pos = saTmp.indexOf(\"\\\"\");\n                        if (pos < 0) {  // no dataDelim\n                            sa2 = sa2+delim+saTmp;\n                            l++;\n                        } else {\n                            sa2 = sa2+saTmp.substring(0,pos);\n                            st[l] = saTmp.substring(pos+1);\n                            break;\n                        }\n                    }\n\n                    //sThisText = sa.substring(1)+sa2;\n                    sThisText = sa.substring(1)+delim+sa2;\n                  //} catch (NoSuchElementException nse) {\n                  } catch (ArrayIndexOutOfBoundsException nse) {\n                    sThisText = \"\";\n                  }\n                }\n\n                if (debug) System.out.println(\"####   Text value='\"+sThisText+\"'\");\n\n              // if not quoted, then take \"as is\"\n              } else {\n                sThisText = sa;\n              }\n\n\n              // now make the VisAD Data \n              try {\n                tValues[values_to_index[1][i]] = \n                        new Text((TextType) thisMT, sThisText);\n\n\n                if (debug) System.out.println(\"tValues[\" + \n                          values_to_index[1][i] + \"] = \" + \n                          tValues[values_to_index[1][i]]);\n              } catch (Exception e) {\n                System.out.println(\" Exception converting \" + \n                                       thisMT + \" to TextType \" + e);\n              }\n\n              \n            // if not Text, then treat as numeric\n            } else {\n              double value = getVal(sa,i);\n              rValues[values_to_index[1][i]] = value;\n              try {\n                  if(prototypeReals[i]==null) {\n                      prototypeReals[i] =    new Real((RealType) thisMT, getVal(sa,i), infos[i].unit);\n                  }\n                  tValues[values_to_index[1][i]] = \n                      prototypeReals[i].cloneButValue(value);\n                  if(debug)System.out.println(\"tValues[\" + \n                    values_to_index[1][i] + \"] = \" + \n                    tValues[values_to_index[1][i]]);\n\n              } catch (Exception e) {\n                System.out.println(\" Exception converting \" + thisMT + \" \" + e);\n              }\n            }\n          }\n        }\n      }\n\n      if(tryToMakeTuple) {\n        try {\n          if (tValues != null) tuple = new Tuple(tValues);\n        } catch (visad.TypeException te) {\n          // do nothing: it means they are all reals\n          // tuple = new RealTuple(tValues);\n          tuple = null;\n          tryToMakeTuple = false;\n        }\n      }\n\n      domainValues.add(dValues);\n      rangeValues.add(rValues);\n      if (tuple != null) tupleValues.add(tuple); \n      if (isRaster) numElements = rValues.length;\n\n      if(onlyReadOneLine) break;\n\n    }\n\n    int numSamples = rangeValues.size(); // # lines of data\n\n// ***********************************************************\n    if (debug) {\n      try {\n        System.out.println(\"domain size = \"+domainValues.size());\n        double[] dt = (double[]) domainValues.get(1);\n        System.out.println(\"domain.array[0] = \"+dt[0]);\n        System.out.println(\"range size = \"+rangeValues.size());\n        System.out.println(\"# samples = \"+numSamples);\n      } catch (Exception er) {System.out.println(\"out range\");}\n    }\n// ***********************************************************\n\n\n    // make Linear1DSets for each possible domain component\n\n    Linear1DSet[] lset = new Linear1DSet[numDom];\n    boolean keepConstant = false;\n    int numVal = numRng; \n    if (numDom == 1) numVal = numSamples;\n    if (numDom == 2 && numRng == 1 && numElements > 1) numVal = numElements;\n    if (numDom > 2 && numRng == 1 && numElements == 1) {\n      numVal = numSamples / (2 * numDom);\n      keepConstant = true;\n    }\n\n    for (int i=0; i<numDom; i++) {\n\n      if (gotDomainRanges[i]) {\n        // if domain was given with a count, use it for 'raster'-type\n        if (numDom == 2 && numRng == 1 && numElements == 1) \n                                   numVal = (int) domainRanges[2][i]; \n\n        lset[i] = new Linear1DSet(domType.getComponent(i), domainRanges[0][i], \n                            domainRanges[1][i], numVal);\n\n        if (debug) System.out.println(\"lset from domain = \"+lset[i]);\n\n      } else if (domainPointer[i] == -1 ) {\n        lset[i] = new Linear1DSet(0., (double)(numVal-1), numVal);\n\n        if (debug) System.out.println(\"lset from range = \"+lset[i]);\n\n      } else {\n        lset[i] = null;\n      }\n\n      if (!keepConstant) numVal = numSamples; \n    }\n\n\n    // now make up the actual domain sets for the function\n    Set domain = null;\n\n    if (numDom == 1) {  // for 1-D domains\n\n      if (lset[0] == null) {\n        domain = createAppropriate1DDomain(domType, numSamples, domainValues);\n\n      } else {\n        domain = lset[0];\n      }\n\n    } else if (numDom == 2) {  // for 2-D domains\n\n      if (lset[0] != null && lset[1] != null) {\n        domain = new Linear2DSet(domType, lset);\n\n      } else {\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k = 0; k < numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n\n        }\n\n        domain = (Set) new Irregular2DSet(domType, samples);\n      }\n        \n    } else if (numDom == 3) {  // for 3-D domains\n    \n      if (lset[0] != null && lset[1] != null && lset[2] != null) {\n        domain = new Linear3DSet(domType, lset);\n\n      } else {\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k = 0; k < numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n\n        }\n\n        domain = (Set) new Irregular3DSet(domType, samples);\n      }\n\n    } else {  // N-D domains (can only use LinearSets!!\n\n      boolean allLinear = true;\n      for (int k = 0; k<numDom; k++) {\n        if (lset[k] == null) allLinear = false;\n      }\n\n      if (allLinear) {\n        if (debug) System.out.println(\"####   Making LinearNDset\");\n        domain = new LinearNDSet(domType, lset);\n\n      } else { \n        if (debug) System.out.println(\"####   Making IrregularSet\");\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k=0; k<numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n        }\n\n        domain = new IrregularSet(domType, samples);\n      }\n    }\n\n\n    try {\n      ff = new FlatField((FunctionType) mt, domain, \n                                null, null, rangeSets, rangeUnits);\n\n    } catch (FieldException fe) {\n      field = new FieldImpl((FunctionType) mt, domain);\n\n    } catch (UnitException fe) {\n      System.out.println(\"####  Problem with Units; attempting to make Field anyway\");\n      field = new FieldImpl((FunctionType) mt, domain);\n    }\n//*************************************************\n    if (debug) {\n      if (ff != null) {\n        System.out.println(\"ff.Length \"+ff.getLength());\n        System.out.println(\"ff.getType \"+ff.getType());\n      }\n      if (field != null) {\n        System.out.println(\"field.Length \"+field.getLength());\n        System.out.println(\"field.getType \"+field.getType());\n      }\n      System.out.println(\"domain = \"+domain);\n      System.out.println(\"size of a = \"+numRng+\" x \"+(numSamples*numElements));\n    }\n//*************************************************\n\n    double[][]a = new double[numRng][numSamples * numElements];\n    Tuple[] at = new Tuple[numSamples];\n    \n    // if this is a raster then the samples are in a slightly\n    // difielderent form ...\n\n    if (isRaster) {\n      int samPointer = 0;\n      for (int i=0; i<numSamples; i++) {\n        double[] rs = (double[])(rangeValues.get(i));\n        for (int j=0; j<numElements; j++) {\n          a[0][samPointer] = rs[j];\n          samPointer ++;\n        }\n      }\n    } else {\n      for (int i=0; i<numSamples; i++) {\n        double[] rs = (double[])(rangeValues.get(i));\n        for (int j=0; j<numRng; j++) {\n          a[j][i] = rs[j];\n        }\n        if (!tupleValues.isEmpty()) {\n          at[i] = (Tuple) tupleValues.get(i); \n        }\n      }\n    }\n\n// set samples\n    if (debug) System.out.println(\"about to field.setSamples\");\n    try {\n    if (ff != null) {\n      if (debug) System.out.println(\"####   ff is not null\");\n      ff.setSamples(a, false);\n      field = (Field) ff;\n\n    } else {\n      if (debug) System.out.println(\"####   ff is null..use FieldImpl\");\n      field.setSamples(at, false);\n    }\n    } catch (Exception ffe) {ffe.printStackTrace(); }\n      \n\n    // make up error estimates and set them\n    ErrorEstimate[] es = new ErrorEstimate[numRng];\n    for (int i=0; i<numRng; i++) {\n      es[i] = new ErrorEstimate(a[i], rangeErrorEstimates[i], rangeUnits[i]);\n    }\n    try {\n        ((FlatField) field).setRangeErrors(es); \n    } catch (FieldException fe) {\n        if (debug) System.out.println(\"caught \"+fe);\n        // not a flatfield\n        // don't setRangeErrors\n    } catch (ClassCastException cce) {\n        if (debug) System.out.println(\"caught \"+cce);\n        // not a flatfield\n        // don't setRangeErrors\n    }\n\n    if (debug) {\n      new visad.jmet.DumpType().dumpDataType(field,System.out);\n      System.out.println(\"field = \"+field);\n    }\n\n    bis.close();\n\n  }\n",
      "fixed": "  void readit(InputStream is, String map, String params) \n                              throws IOException, VisADException {\n    // read the ASCII file, using commas as field separators\n    // first line is a header line\n\n    ff = null;\n    field = null;\n\n    if (debug) System.out.println(\"####   Text Adapter v2.x running\");\n\n    BufferedReader bis = new BufferedReader(new InputStreamReader(is));\n\n    // mapping defines how the names are mapped\n    // for example:   (x,y) => (one, two, three)\n\n    String maps = null;\n    if (map == null) {\n      maps = readLine(bis);\n      if(maps != null) {\n          maps = maps.trim();\n      }\n    } else {\n      maps = map;\n    }\n\n    if (maps != null) {\n       maps = makeMT(maps);\n    }\n    if (maps == null) {\n      throw new visad.data.BadFormException(\n        \"TextAdapter: Invalid or missing MathType\");\n    }\n\n    if (debug) System.out.println(\"Specified MathType = \"+maps);\n\n    // but first, we need to get the column headers because they\n    // may have [units] associated with them.  The column headers\n    // primarily define where the data are.\n\n    String hdr = null;\n    if (params == null) {\n      hdr = readLine(bis);\n    } else {\n      hdr = params;\n    }\n\n    String hdrDelim = DELIM;\n    if (DELIM == null) {\n      if (hdr.indexOf(BLANK) != -1) hdrDelim = BLANK_DELIM; \n      if (hdr.indexOf(COMMA) != -1) hdrDelim = COMMA; \n      if (hdr.indexOf(SEMICOLON) != -1) hdrDelim = SEMICOLON; \n      if (hdr.indexOf(TAB) != -1) hdrDelim = TAB; \n\n      if (debug) System.out.println(\"Using header delimiter = \"+\n                                     (hdrDelim.getBytes())[0]);\n    }\n\n    String[] sthdr = hdr.split(hdrDelim);\n    int nhdr = sthdr.length;\n    infos    = new HeaderInfo[nhdr];\n    for(int i=0;i<infos.length;i++) {\n      infos[i] = new HeaderInfo();\n    }\n    Real[] prototypeReals = new Real[nhdr];\n    hdrColumns = new int[2][nhdr];\n    int numHdrValues=0;\n\n    // pre-scan of the header names to seek out Units\n    // since we cannot change a RealType once it's defined!!\n\n    for (int i=0; i<nhdr; i++) {\n      String name = sthdr[i].trim();\n      String hdrUnitString = null;\n      hdrColumns[0][i] = -1; // indicating no fixed columns\n      \n      int m = name.indexOf(\"[\");\n\n      if (m == -1) {\n          infos[i].name = name;\n          hdrUnitString = null;\n      } else {\n        int m2 = name.indexOf(\"]\");\n        if (m2 == -1) {\n          throw new VisADException(\"TextAdapter: Bad [descriptor] named in:\"+name);\n        }\n\n        // now parse items: unit=xxx miss=xxx interval=xxx error=xxx\n\n        // 1. tokenize on \" \"\n        // 2. scan each token, retokenizing on \"=\"\n        // 3. if (has no \"=\") && (is first one) then treat as Unit\n        // 4. otherwise, look for keys \"unit\" \"miss\" \"inter\" \"err\" \"scale\" \"offset\" \"pos\"\n      \n        //    and fill in the values in array[i]\n\n        if (m2 >= name.length()) {\n          infos[i].name = name.substring(0,m).trim();\n        } else {\n          infos[i].name = (name.substring(0,m)+name.substring(m2+1)).trim();\n        }\n\n        String cl = name.substring(m+1,m2).trim();\n        String[] stcl = cl.split(BLANK_DELIM);\n        int ncl = stcl.length;\n\n        if (ncl == 1 && cl.indexOf(\"=\") == -1) {\n          hdrUnitString = cl;  // backward compatible...\n\n        } else {\n          for (int l = 0; l  < ncl; l++) {\n            String s = stcl[l];\n            String[] sts = s.split(\"=\");\n            if (sts.length != 2) {\n              throw new VisADException(\"TextAdapter: Invalid clause in: \"+s);\n            }\n            String tok = sts[0];\n            String val = sts[1];\n            \n            // check for quoted strings\n            if (val.startsWith(\"\\\"\")) {\n\n              // see if ending quote also fetched\n              if (val.endsWith(\"\\\"\")) {\n                String v2 = val.substring(1,val.length()-1);\n                val = v2;\n\n              } else {\n                // if not, then reparse stcl to suck up spaces...\n                try {\n                  String v2=\"\";\n                  for (int q=l+1; q < ncl; q++) {\n                      String  vTmp = stcl[q];\n                      // find next token that has a \" in it\n                      int pos = vTmp.indexOf(\"\\\"\");\n                      l++;\n                      if (pos < 0) {  // no \"\n                          v2 = v2+\" \"+vTmp;\n                      } else {\n                          v2 = v2+\" \"+vTmp.substring(0,pos);\n                          break;\n                      }\n                  }\n                  String v3 = val.substring(1)+v2;\n                  val = v3;\n\n                //} catch (NoSuchElementException nse2) {\n                } catch (ArrayIndexOutOfBoundsException nse2) {\n                  val=\"\";\n                }\n              }\n            }\n\n            if (debug) System.out.println(\"####   tok = \"+tok+ \" val = '\"+val+\"'\");\n\n            if (tok.toLowerCase().startsWith(ATTR_UNIT)) {\n              hdrUnitString = val;\n\n            } else if (tok.toLowerCase().startsWith(ATTR_MISSING)) {\n                infos[i].missingString = val.trim();\n              try {\n                infos[i].missingValue = Double.parseDouble(val);\n              } catch (java.lang.NumberFormatException me) {\n                  infos[i].missingValue = Double.NaN;\n              }\n            } else if (tok.toLowerCase().startsWith(ATTR_INTERVAL)) {\n              infos[i].isInterval = -1;\n              if (val.toLowerCase().startsWith(\"t\")) infos[i].isInterval = 1;\n              if (val.toLowerCase().startsWith(\"f\")) infos[i].isInterval = 0;\n              if (infos[i].isInterval == -1) {\n                throw new VisADException(\"TextAdapter: Value of \\'interval\\' must be \\'true\\' or \\'false\\'\");\n              }\n            } else if (tok.toLowerCase().startsWith(ATTR_ERROR)) {\n                infos[i].errorEstimate = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_SCALE)) {\n                infos[i].scale = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_OFFSET)) {\n              infos[i].offset = Double.parseDouble(val);\n            } else if (tok.toLowerCase().startsWith(ATTR_VALUE)) {\n              infos[i].fixedValue = val.trim();\n              numHdrValues++;\n            } else if (tok.toLowerCase().startsWith(ATTR_COLSPAN)) {\n              infos[i].colspan = (int)Double.parseDouble(val.trim());\n            } else if (tok.toLowerCase().startsWith(ATTR_POSITION)) {\n              String[] stp = val.split(\":\");\n              if (stp.length != 2) {\n                throw new VisADException(\"TextAdapter: invalid Position parameter in:\"+s);\n              }\n              hdrColumns[0][i] = Integer.parseInt(stp[0].trim());\n              hdrColumns[1][i] = Integer.parseInt(stp[1].trim());\n\n            } else if (tok.toLowerCase().startsWith(ATTR_FORMAT)) {\n                infos[i].formatString = val.trim();\n            } else if (tok.toLowerCase().startsWith(ATTR_TIMEZONE)) {\n                infos[i].tzString = val.trim();\n            } else {\n              throw new VisADException(\"TextAdapter: invalid token name: \"+s);\n            }\n\n          }\n        }\n\n      }\n\n\n      if (debug) \n            System.out.println(\"hdr name = \"+infos[i]+\" units=\"+\n             hdrUnitString+\n             \" miss=\"+infos[i].missingValue+\" interval=\"+infos[i].isInterval+ \n             \" errorest=\"+infos[i].errorEstimate+\" scale=\"+infos[i].scale+\n             \" offset=\"+infos[i].offset+\" pos=\"+hdrColumns[0][i]+\":\"+\n             hdrColumns[1][i]);\n\n      Unit u = null;\n      if (hdrUnitString != null && \n                !hdrUnitString.trim().equalsIgnoreCase(\"null\") ) {\n        try {\n\n          u = visad.data.units.Parser.parse(hdrUnitString.trim());\n        } catch (Exception ue) {\n\n          try {\n            u = visad.data.units.Parser.parse(\n                           hdrUnitString.trim().replace(' ','_'));\n          } catch (Exception ue2) {\n            System.out.println(\"Unit name problem:\"+ue+\" with: \"+hdrUnitString);\n            u = null;\n          }\n        }\n      }\n\n      if (debug) System.out.println(\"####   assigned Unit as u=\"+u);\n\n\n      String rttemp = infos[i].name.trim();\n      if (rttemp.indexOf(\"(Text)\") == -1) {\n\n        int parenIndex = rttemp.indexOf(\"(\");\n\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\"[\");\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\"{\");\n        if (parenIndex < 0) parenIndex = rttemp.indexOf(\" \");\n        String rtname = parenIndex < 0 ? rttemp.trim() : rttemp.substring(0,parenIndex);\n\n\n        RealType rt = RealType.getRealType(rtname, u, null, infos[i].isInterval);\n\n        if (rt == null) {  // tried to re-use with different units\n          if (debug) System.out.println(\"####   rt was returned as null\");\n          if (u != null) System.out.println(\"####  Could not make RealType using specified Unit (\"+hdrUnitString+\") for parameter name: \"+rtname);\n          rt = RealType.getRealType(rtname);\n        }\n\n        // get a compatible unit, if necessary\n\n        if (rt.equals(visad.RealType.Time)) {\n          GOTTIME = true;\n          if (debug) System.out.println(\"####  found a visad.RealType.Time component\");\n        } else {\n          GOTTIME = false;\n        }\n\n\n        if (u == null) u = rt.getDefaultUnit();\n        if(debug) System.out.println(\"####  retrieve units from RealType = \"+u);\n      }\n\n      infos[i].unit = u;\n    }\n\n    // get the MathType of the function\n\n    MathType mt = null;\n    try {\n      mt = MathType.stringToType(maps);\n    } catch (Exception mte) {\n      System.out.println(\"####  Exception: \"+mte);\n      throw new VisADException(\"TextAdapter: MathType badly formed or missing: \"+maps);\n    }\n\n    if (debug) {\n      System.out.println(mt);\n      new visad.jmet.DumpType().dumpMathType(mt,System.out);\n    }\n\n    // now get the names of the domain variables and range variables.\n    String[] domainNames = null;\n    String[] rangeNames = null;\n    int numDom = 0;\n    int numRng = 0;\n    RealTupleType domType;\n    TupleType rngType;\n\n    if (mt instanceof FunctionType) {\n      domType = ((FunctionType)mt).getDomain();\n      numDom = domType.getDimension();\n      domainNames = new String[numDom];\n\n      for (int i=0; i<numDom; i++) {\n        MathType comp = domType.getComponent(i);\n        domainNames[i] = ((RealType)comp).toString().trim();\n        if (debug) System.out.println(\"dom \"+i+\" = \"+domainNames[i]);\n      }\n\n      rngType = (TupleType) ((FunctionType)mt).getRange();\n      numRng = rngType.getDimension();\n      rangeNames = new String[numRng];\n      rangeSets = new Set[numRng];\n      for (int i=0; i<numRng; i++) {\n        MathType comp = rngType.getComponent(i);\n        rangeNames[i] = (comp).toString().trim();\n        if (debug) System.out.println(\"range \"+i+\" = \"+rangeNames[i]);\n        if (comp instanceof RealType) {\n          rangeSets[i] = ((RealType) comp).getDefaultSet();\n          if (rangeSets[i] == null) {\n            if (comp.equals(RealType.Time)) {\n              rangeSets[i] = new DoubleSet(new SetType(comp));\n            } else {\n              rangeSets[i] = new FloatSet(new SetType(comp));\n            }\n          }\n        } else {\n          rangeSets[i] = null;  // something else is wrong here...\n        }\n        if (debug) System.out.println(\"####  rangeSet = \"+rangeSets[i]);\n;\n      }\n\n    } else { \n      throw new visad.VisADException(\"TextAdapter: Math Type is not a simple FunctionType\");\n    }\n\n\n// now for each header label, determine if it's a domain or\n// range component -- and if so, which one.\n\n// also, if it's a domain component, allow for name(first:last[:number])\n//\n// and if none of the domain components appear in the list, then\n// they are computed as name(0:N-1)\n\n    int[] domainPointer = new int[numDom];\n    double[][] domainRanges = new double[3][numDom]; // min, max, numb\n    boolean[] gotDomainRanges = new boolean[numDom];\n    domainErrorEstimates = new double[numDom];\n    domainUnits = new Unit[numDom];\n    rangeErrorEstimates = new double[numRng];\n    rangeUnits = new Unit[numRng];\n\n    int countDomain = 0;\n\n    for (int i=0; i<numDom; i++) {\n      domainPointer[i] = -1;\n      gotDomainRanges[i] = false;\n      domainErrorEstimates[i] = Double.NaN;\n      domainUnits[i] = null;\n    }\n\n    int[] rangePointer = new int[numRng];\n    int countRange = 0;\n\n    for (int i=0; i<numRng; i++) {\n      rangePointer[i] = -1;\n      rangeErrorEstimates[i] = Double.NaN;\n      rangeUnits[i] = null;\n    }\n\n    int countValues = -1;\n    values_to_index = new int[3][nhdr];\n\n    for (int i=0; i<nhdr; i++) {\n      values_to_index[0][i] = -1;  // points to domains\n      values_to_index[1][i] = -1;  // points to ranges\n      values_to_index[2][i] = -1;  // points to names/units/etc\n      countValues ++;\n\n      String name = infos[i].name;\n\n\n      // see if it's a domain name\n      boolean gotName = false;\n\n      // is there a \"min:max\" clause?\n      String test_name = name;\n      int n = test_name.indexOf(\"(\");\n      if (n != -1) {\n        // but allow for \"(Text)\" \n        if ((test_name.indexOf(\"(Text)\")) == -1) {\n          test_name = name.substring(0,n).trim();\n          countValues --;  // this value wont appear in data!\n          countDomain --; // and is a pre-defined, linear set\n        }\n      }\n\n      // try to find the column header name in the domain name list\n      for (int k=0; k<numDom; k++) {\n\n        if (test_name.equals(domainNames[k]) ) { \n          domainPointer[k] = countValues;\n          domainErrorEstimates[k] = infos[i].errorEstimate;\n          domainUnits[k] = infos[i].unit;\n          gotName = true;\n          countDomain ++;\n          // now see if a list is given...\n          if (n != -1) {\n\n            try {\n\n              String ss = name.substring(n+1,name.length()-1);\n              String[] sct = ss.split(\":\");\n              String first = sct[0].trim();\n              String second = sct[1].trim();\n              String third = \"1\";\n              if (sct.length == 3) third = sct[2].trim();\n              domainRanges[0][k] = Double.parseDouble(first);\n              domainRanges[1][k] = Double.parseDouble(second);\n              domainRanges[2][k] = Double.parseDouble(third);\n              gotDomainRanges[k] = true;\n\n            } catch (Exception ef) {\n              throw new VisADException(\n       \"TextAdapter: Error while interpreting min:max values for domain \"+name);\n            }\n\n          } else if (countValues > -1) { // if no list, get from file\n            values_to_index[0][countValues] = k;\n            values_to_index[2][countValues] = i;\n          }\n\n          break;\n       }\n\n    } \n\n    if (gotName) continue;\n\n    // or see if its a range name...\n\n    for (int k=0; k<numRng; k++) {\n      if (name.equals(rangeNames[k]) ) {\n        rangePointer[k] = countValues;\n        rangeErrorEstimates[k] = infos[i].errorEstimate;\n        rangeUnits[k] = infos[i].unit;\n        countRange ++;\n        values_to_index[1][countValues] = k;\n        values_to_index[2][countValues] = i;\n        gotName = true;\n      }\n    }\n  }\n\n\n// huge debug printout...\n// *****************************************************************\n\n  if (debug) {\n    System.out.println(\"countDom/numDom=\"+countDomain+\" \"+numDom);\n\n    System.out.println(\"countRange/numRng=\"+countRange+\" \"+numRng);\n\n    System.out.println(\"Domain info:\");\n    for (int i=0; i<numDom; i++) {\n      System.out.println(\"Dom name / index = \"+domainNames[i]+\"  \"+\n             domainPointer[i]);\n\n      if (gotDomainRanges[i]) {\n        System.out.println(\"    ...\"+domainRanges[0][i]+\"  \"+\n            domainRanges[1][i]+\"    \"+domainRanges[2][i]);\n      }\n    }\n\n    System.out.println(\"Range info:\");\n    for (int i=0; i<numRng; i++) {\n      System.out.println(\"Rng name / index / error est = \"+rangeNames[i]+\"  \"+\n             rangePointer[i]+ \"  \" + rangeErrorEstimates[i] +\" \"+\n             rangeUnits[i]);\n    }\n\n    System.out.println(\"values_to_index pointers = \");\n    for (int i=0; i<nhdr; i++) {\n      System.out.println(\" inx / value = \"+i+ \n              \" \"+values_to_index[0][i]+\"    \"+values_to_index[1][i]+\n              \" \"+values_to_index[2][i]);\n    }\n  }\n\n// ***************************************************************\n\n\n    // for each line of text, put the values into the ArrayList\n    ArrayList domainValues = new ArrayList();\n    ArrayList rangeValues = new ArrayList();\n    ArrayList tupleValues = new ArrayList(); \n    boolean tryToMakeTuple = true;\n    Tuple tuple = null;\n    \n    String dataDelim = DELIM;\n    boolean isRaster = false;\n    int numElements = 1;\n\n    // in the 'raster array' case, the numRng value will be 1,\n    // along with the countRange.  numDomain must be 2.\n\n    // if the domain is 2D, then get values from the first\n    // matching column to the end...\n    if (countRange == 1 && numRng == 1 && \n                numDom == 2 && countDomain < 2) isRaster = true;\n\n    int index;\n    while (true) {\n      String s = bis.readLine();\n      if (debug) System.out.println(\"read:\"+s);\n      if (s == null) break;\n      if (!isText(s)) return;\n      if (isComment(s)) continue;\n      if (dataDelim == null) {\n        if (s.indexOf(BLANK) != -1) dataDelim = BLANK_DELIM; \n        if (s.indexOf(COMMA) != -1) dataDelim = COMMA; \n        if (s.indexOf(SEMICOLON) != -1) dataDelim = SEMICOLON; \n        if (s.indexOf(TAB) != -1) dataDelim = TAB; \n\n        if (debug) System.out.println(\"Using data delimiter = \"+\n                                       (dataDelim.getBytes())[0]);\n      }\n\n      \n      if((index=s.indexOf(\"=\"))>=0) {\n        String name  = s.substring(0,index).trim();\n        String value  = s.substring(index+1).trim();\n        boolean foundIt = false;\n        for(int paramIdx=0;paramIdx<infos.length;paramIdx++) {\n            if(infos[paramIdx].isParam(name)) {\n                if(infos[paramIdx].fixedValue==null) {\n                    numHdrValues++;\n                }\n                infos[paramIdx].fixedValue = value;\n                foundIt = true;\n                break;\n            }\n        }\n        if(!foundIt) {\n           throw new VisADException(\n                    \"TextAdapter: Cannot find field with name:\" +name +\" from line:\" + s);\n        }\n        continue;\n      }\n\n\n\n      String[] st = s.split(dataDelim);\n      int n = st.length;\n      if (n < 1) continue; // something is wrong if this happens!\n\n      double [] dValues = new double[numDom];\n      double [] rValues = null;\n      Data [] tValues = null;\n\n      if (isRaster) {\n\n        if (debug) System.out.println(\"probably a raster...\");\n        boolean gotFirst = false;\n        int rvaluePointer = 0;\n        int irange = 0;\n        for (int i=0; i<n; i++) {\n\n          String sa = st[i];\n          \n          if (i >= nhdr) {  // are we past where domain would be found?\n\n            if (!gotFirst) {\n              throw new VisADException(\n                        \"TextAdapter: Cannot find first raster value\");\n            }\n\n            rvaluePointer ++;\n            rValues[rvaluePointer] = getVal(sa, irange);\n\n          } else {  // or are we still looking for domain?\n          \n            if (values_to_index[0][i] != -1) {\n              dValues[values_to_index[0][i]] = getVal(sa, i);\n            }\n\n            if (gotFirst) {  // already gathering data\n              rvaluePointer ++;\n              rValues[rvaluePointer] = getVal(sa, irange);\n\n            } else {\n               if (values_to_index[1][i] != -1) {\n                 // cannot dimension the array until we have found\n                 // the first set of range values!!\n                 rValues = new double[n - i];\n                 irange = i;\n                 rValues[rvaluePointer] = getVal(sa, irange);\n                 gotFirst = true;\n               }\n            }\n\n          }\n        }\n         \n      } else {  // is probably NOT a raster\n\n        tValues = new Data[numRng];\n      \n        if (debug) System.out.println(\"probably not a raster...\");\n        rValues = new double[numRng];\n        double thisDouble; \n        MathType thisMT;\n        if (n > nhdr) n = nhdr; // in case the # tokens > # parameters\n        n +=numHdrValues;\n\n        int l = 0;   // token counter\n        for (int i=0; i<nhdr; i++) {   // loop over the columns\n          String sa;\n          if(infos[i].fixedValue!=null) {\n            sa = infos[i].fixedValue;\n          }  else if (l >= st.length) {   // more params than tokens\n            sa = \"\";                    // need to have a missing value\n          } else {\n            sa = st[l++].trim();\n            int moreColumns = infos[i].colspan-1;\n            while (moreColumns>0) {\n                sa = sa + \" \" + st[l++].trim();\n                moreColumns--;\n            }\n          }\n\n          String sThisText;\n\n          if (values_to_index[0][i] != -1) {\n            dValues[values_to_index[0][i]] = getVal(sa, i);\n          } else if (values_to_index[1][i] != -1) {\n\n            thisMT = rngType.getComponent(values_to_index[1][i]);\n            \n            if (thisMT instanceof TextType) {\n\n              // if Text, then check for quoted string\n              if (sa.startsWith(\"\\\"\")) {\n                if (sa.endsWith(\"\\\"\")) {  // if single token ends with quote\n                  String sa2 = sa.substring(1,sa.length()-1);\n                  sThisText = sa2;\n                } else {\n                  // TODO:  work on this\n                  try {\n                    String delim = \n                        dataDelim.equals(BLANK_DELIM) ? BLANK : dataDelim;\n                    String sa2=\"\";\n                    for (int q=l; q < st.length; q++) {\n                        String  saTmp = st[q];\n                        // find next token that has a \" in it\n                        int pos = saTmp.indexOf(\"\\\"\");\n                        l++;\n                        if (pos < 0) {  // no dataDelim\n                            sa2 = sa2+delim+saTmp;\n                        } else {\n                            sa2 = sa2+saTmp.substring(0,pos);\n                            //st[l] = saTmp.substring(pos+1);\n                            break;\n                        }\n                    }\n\n                    //sThisText = sa.substring(1)+sa2;\n                    sThisText = sa.substring(1)+delim+sa2;\n                  //} catch (NoSuchElementException nse) {\n                  } catch (ArrayIndexOutOfBoundsException nse) {\n                    sThisText = \"\";\n                  }\n                }\n\n                if (debug) System.out.println(\"####   Text value='\"+sThisText+\"'\");\n\n              // if not quoted, then take \"as is\"\n              } else {\n                sThisText = sa;\n              }\n\n\n              // now make the VisAD Data \n              try {\n                tValues[values_to_index[1][i]] = \n                        new Text((TextType) thisMT, sThisText);\n\n\n                if (debug) System.out.println(\"tValues[\" + \n                          values_to_index[1][i] + \"] = \" + \n                          tValues[values_to_index[1][i]]);\n              } catch (Exception e) {\n                System.out.println(\" Exception converting \" + \n                                       thisMT + \" to TextType \" + e);\n              }\n\n              \n            // if not Text, then treat as numeric\n            } else {\n              double value = getVal(sa,i);\n              rValues[values_to_index[1][i]] = value;\n              try {\n                  if(prototypeReals[i]==null) {\n                      prototypeReals[i] =    new Real((RealType) thisMT, getVal(sa,i), infos[i].unit);\n                  }\n                  tValues[values_to_index[1][i]] = \n                      prototypeReals[i].cloneButValue(value);\n                  if(debug)System.out.println(\"tValues[\" + \n                    values_to_index[1][i] + \"] = \" + \n                    tValues[values_to_index[1][i]]);\n\n              } catch (Exception e) {\n                System.out.println(\" Exception converting \" + thisMT + \" \" + e);\n              }\n            }\n          }\n        }\n      }\n\n      if(tryToMakeTuple) {\n        try {\n          if (tValues != null) tuple = new Tuple(tValues);\n        } catch (visad.TypeException te) {\n          // do nothing: it means they are all reals\n          // tuple = new RealTuple(tValues);\n          tuple = null;\n          tryToMakeTuple = false;\n        }\n      }\n\n      domainValues.add(dValues);\n      rangeValues.add(rValues);\n      if (tuple != null) tupleValues.add(tuple); \n      if (isRaster) numElements = rValues.length;\n\n      if(onlyReadOneLine) break;\n\n    }\n\n    int numSamples = rangeValues.size(); // # lines of data\n\n// ***********************************************************\n    if (debug) {\n      try {\n        System.out.println(\"domain size = \"+domainValues.size());\n        double[] dt = (double[]) domainValues.get(1);\n        System.out.println(\"domain.array[0] = \"+dt[0]);\n        System.out.println(\"range size = \"+rangeValues.size());\n        System.out.println(\"# samples = \"+numSamples);\n      } catch (Exception er) {System.out.println(\"out range\");}\n    }\n// ***********************************************************\n\n\n    // make Linear1DSets for each possible domain component\n\n    Linear1DSet[] lset = new Linear1DSet[numDom];\n    boolean keepConstant = false;\n    int numVal = numRng; \n    if (numDom == 1) numVal = numSamples;\n    if (numDom == 2 && numRng == 1 && numElements > 1) numVal = numElements;\n    if (numDom > 2 && numRng == 1 && numElements == 1) {\n      numVal = numSamples / (2 * numDom);\n      keepConstant = true;\n    }\n\n    for (int i=0; i<numDom; i++) {\n\n      if (gotDomainRanges[i]) {\n        // if domain was given with a count, use it for 'raster'-type\n        if (numDom == 2 && numRng == 1 && numElements == 1) \n                                   numVal = (int) domainRanges[2][i]; \n\n        lset[i] = new Linear1DSet(domType.getComponent(i), domainRanges[0][i], \n                            domainRanges[1][i], numVal);\n\n        if (debug) System.out.println(\"lset from domain = \"+lset[i]);\n\n      } else if (domainPointer[i] == -1 ) {\n        lset[i] = new Linear1DSet(0., (double)(numVal-1), numVal);\n\n        if (debug) System.out.println(\"lset from range = \"+lset[i]);\n\n      } else {\n        lset[i] = null;\n      }\n\n      if (!keepConstant) numVal = numSamples; \n    }\n\n\n    // now make up the actual domain sets for the function\n    Set domain = null;\n\n    if (numDom == 1) {  // for 1-D domains\n\n      if (lset[0] == null) {\n        domain = createAppropriate1DDomain(domType, numSamples, domainValues);\n\n      } else {\n        domain = lset[0];\n      }\n\n    } else if (numDom == 2) {  // for 2-D domains\n\n      if (lset[0] != null && lset[1] != null) {\n        domain = new Linear2DSet(domType, lset);\n\n      } else {\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k = 0; k < numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n\n        }\n\n        domain = (Set) new Irregular2DSet(domType, samples);\n      }\n        \n    } else if (numDom == 3) {  // for 3-D domains\n    \n      if (lset[0] != null && lset[1] != null && lset[2] != null) {\n        domain = new Linear3DSet(domType, lset);\n\n      } else {\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k = 0; k < numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n\n        }\n\n        domain = (Set) new Irregular3DSet(domType, samples);\n      }\n\n    } else {  // N-D domains (can only use LinearSets!!\n\n      boolean allLinear = true;\n      for (int k = 0; k<numDom; k++) {\n        if (lset[k] == null) allLinear = false;\n      }\n\n      if (allLinear) {\n        if (debug) System.out.println(\"####   Making LinearNDset\");\n        domain = new LinearNDSet(domType, lset);\n\n      } else { \n        if (debug) System.out.println(\"####   Making IrregularSet\");\n        float[][] samples = new float[numDom][numSamples];\n\n        for (int k=0; k<numDom; k++) {\n          if (lset[k] == null) {\n            samples[k] = (getDomSamples(k, numSamples, domainValues))[0];\n          } else {\n            samples[k] = (lset[k].getSamples())[0];\n          }\n        }\n\n        domain = new IrregularSet(domType, samples);\n      }\n    }\n\n\n    try {\n      ff = new FlatField((FunctionType) mt, domain, \n                                null, null, rangeSets, rangeUnits);\n\n    } catch (FieldException fe) {\n      field = new FieldImpl((FunctionType) mt, domain);\n\n    } catch (UnitException fe) {\n      System.out.println(\"####  Problem with Units; attempting to make Field anyway\");\n      field = new FieldImpl((FunctionType) mt, domain);\n    }\n//*************************************************\n    if (debug) {\n      if (ff != null) {\n        System.out.println(\"ff.Length \"+ff.getLength());\n        System.out.println(\"ff.getType \"+ff.getType());\n      }\n      if (field != null) {\n        System.out.println(\"field.Length \"+field.getLength());\n        System.out.println(\"field.getType \"+field.getType());\n      }\n      System.out.println(\"domain = \"+domain);\n      System.out.println(\"size of a = \"+numRng+\" x \"+(numSamples*numElements));\n    }\n//*************************************************\n\n    double[][]a = new double[numRng][numSamples * numElements];\n    Tuple[] at = new Tuple[numSamples];\n    \n    // if this is a raster then the samples are in a slightly\n    // difielderent form ...\n\n    if (isRaster) {\n      int samPointer = 0;\n      for (int i=0; i<numSamples; i++) {\n        double[] rs = (double[])(rangeValues.get(i));\n        for (int j=0; j<numElements; j++) {\n          a[0][samPointer] = rs[j];\n          samPointer ++;\n        }\n      }\n    } else {\n      for (int i=0; i<numSamples; i++) {\n        double[] rs = (double[])(rangeValues.get(i));\n        for (int j=0; j<numRng; j++) {\n          a[j][i] = rs[j];\n        }\n        if (!tupleValues.isEmpty()) {\n          at[i] = (Tuple) tupleValues.get(i); \n        }\n      }\n    }\n\n// set samples\n    if (debug) System.out.println(\"about to field.setSamples\");\n    try {\n    if (ff != null) {\n      if (debug) System.out.println(\"####   ff is not null\");\n      ff.setSamples(a, false);\n      field = (Field) ff;\n\n    } else {\n      if (debug) System.out.println(\"####   ff is null..use FieldImpl\");\n      field.setSamples(at, false);\n    }\n    } catch (Exception ffe) {ffe.printStackTrace(); }\n      \n\n    // make up error estimates and set them\n    ErrorEstimate[] es = new ErrorEstimate[numRng];\n    for (int i=0; i<numRng; i++) {\n      es[i] = new ErrorEstimate(a[i], rangeErrorEstimates[i], rangeUnits[i]);\n    }\n    try {\n        ((FlatField) field).setRangeErrors(es); \n    } catch (FieldException fe) {\n        if (debug) System.out.println(\"caught \"+fe);\n        // not a flatfield\n        // don't setRangeErrors\n    } catch (ClassCastException cce) {\n        if (debug) System.out.println(\"caught \"+cce);\n        // not a flatfield\n        // don't setRangeErrors\n    }\n\n    if (debug) {\n      new visad.jmet.DumpType().dumpDataType(field,System.out);\n      System.out.println(\"field = \"+field);\n    }\n\n    bis.close();\n\n  }\n"
    },
    {
      "id": "example-846",
      "name": "Bug Example 846",
      "description": "Bug case from index 846",
      "buggy": "    @Override public List<QlockWord> getTime(int minute, int hour) {\n        if (hour > 12) {\n            hour -= 12;\n        }\n        if (hour <= 0) {\n            hour += 12;\n        }\n\n        if (minute > 60) {\n            minute -= 60;\n            hour++;\n        }\n        if (minute < 0) {\n            minute += 60;\n            hour--;\n        }\n\n        if (minute %5 == 0) {\n            p1 = false;\n            p2 = false;\n            p3 = false;\n            p4 = false;\n        }\n\n        if (minute %10 == 1 || minute %10 == 6) {\n            p1 = true;\n        }\n\n        if (minute %10 == 2 || minute %10 == 7) {\n            p1 = true;\n            p2 = true;\n        }\n\n        if (minute %10 == 3 || minute %10 == 8) {\n            p1 = true;\n            p2 = true;\n            p3 = true;\n        }\n\n        if (minute %10 == 4 || minute %10 == 9) {\n            p1 = true;\n            p2 = true;\n            p3 = true;\n            p4 = true;\n        }\n\n        minute -= minute%5;\n\n        timeList.clear();\n\n        timeList.add(QlockLanguage.ES);\n        timeList.add(QlockLanguage.IST);\n        switch (minute) {\n            case 0:\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                timeList.add(QlockLanguage.UHR);\n                break;\n            case 5:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 10:\n                timeList.add(QlockLanguage.ZEHN);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 15:\n                timeList.add(QlockLanguage.VIERTEL);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 20:\n                timeList.add(QlockLanguage.ZWANZIG);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 25:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.VOR);\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 30:\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 35:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 40:\n                timeList.add(QlockLanguage.ZWANZIG);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 45:\n                timeList.add(QlockLanguage.VIERTEL);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 50:\n                timeList.add(QlockLanguage.ZEHN);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 55:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n        }\n        return timeList;\n    }\n",
      "fixed": "    @Override public List<QlockWord> getTime(int minute, int hour) {\n        if (hour > 12) {\n            hour -= 12;\n        }\n        if (hour <= 0) {\n            hour += 12;\n        }\n\n        if (minute > 60) {\n            minute -= 60;\n            hour++;\n        }\n        if (minute < 0) {\n            minute += 60;\n            hour--;\n        }\n\n        if (minute %5 == 0) {\n            p1 = false;\n            p2 = false;\n            p3 = false;\n            p4 = false;\n        }\n\n        if (minute %10 == 1 || minute %10 == 6) {\n            p1 = true;\n        }\n\n        if (minute %10 == 2 || minute %10 == 7) {\n            p1 = true;\n            p2 = true;\n        }\n\n        if (minute %10 == 3 || minute %10 == 8) {\n            p1 = true;\n            p2 = true;\n            p3 = true;\n        }\n\n        if (minute %10 == 4 || minute %10 == 9) {\n            p1 = true;\n            p2 = true;\n            p3 = true;\n            p4 = true;\n        }\n\n        minute -= minute%5;\n\n        timeList.clear();\n\n        timeList.add(QlockLanguage.ES);\n        timeList.add(QlockLanguage.IST);\n        switch (minute) {\n            case 0:\n                timeList.add(hour == 10 ? QlockLanguage.ZEHN1 : QlockLanguage.valueOf(LOOKUP.get(hour)));\n                timeList.add(QlockLanguage.UHR);\n                break;\n            case 5:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 10:\n                timeList.add(QlockLanguage.ZEHN);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 15:\n                timeList.add(QlockLanguage.VIERTEL);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 20:\n                timeList.add(QlockLanguage.ZWANZIG);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.valueOf(LOOKUP.get(hour)));\n                break;\n            case 25:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.VOR);\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 30:\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 35:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.NACH);\n                timeList.add(QlockLanguage.HALB);\n                addHour(timeList, hour);\n                break;\n            case 40:\n                timeList.add(QlockLanguage.ZWANZIG);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 45:\n                timeList.add(QlockLanguage.VIERTEL);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 50:\n                timeList.add(QlockLanguage.ZEHN);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n            case 55:\n                timeList.add(QlockLanguage.FÜNF1);\n                timeList.add(QlockLanguage.VOR);\n                addHour(timeList, hour);\n                break;\n        }\n        return timeList;\n    }\n"
    },
    {
      "id": "example-888",
      "name": "Bug Example 888",
      "description": "Bug case from index 888",
      "buggy": "\tpublic void testDefaultAgentRepoAndBundlePoolFromProfileRepo() {\n\t\tFile testData = getTestData(\"0.1\", \"testData/sdkpatchingtest\");\n\t\t// /p2/org.eclipse.equinox.p2.engine/profileRegistry\");\n\t\tFile tempFolder = getTempFolder();\n\t\tcopy(\"0.2\", testData, tempFolder);\n\t\tnew SimpleArtifactRepositoryFactory().create(tempFolder.toURI(), \"\", \"\", null);\n\n\t\tFile defaultAgenRepositoryDirectory = new File(tempFolder, \"p2/org.eclipse.equinox.p2.core\");\n\t\tnew SimpleArtifactRepositoryFactory().create(defaultAgenRepositoryDirectory.toURI(), \"\", \"\", null);\n\n\t\tFile profileRegistryFolder = new File(tempFolder, \"p2/org.eclipse.equinox.p2.engine/profileRegistry\");\n\t\tSimpleProfileRegistry registry = new SimpleProfileRegistry(profileRegistryFolder, null, false);\n\t\tIProfile profile = registry.getProfile(\"SDKProfile\");\n\t\tassertNotNull(profile);\n\n\t\tCollector profileCollector = profile.query(InstallableUnitQuery.ANY, new Collector(), getMonitor());\n\t\tassertFalse(profileCollector.isEmpty());\n\n\t\tFile simpleProfileFolder = new File(profileRegistryFolder, \"SDKProfile.profile\");\n\t\tassertTrue(simpleProfileFolder.exists());\n\n\t\tFile timeStampedProfile = new File(simpleProfileFolder, \"\" + profile.getTimestamp() + \".profile\");\n\t\tassertTrue(timeStampedProfile.exists());\n\n\t\tIArtifactRepositoryManager manager = (IArtifactRepositoryManager) ServiceHelper.getService(TestActivator.context, IArtifactRepositoryManager.class.getName());\n\t\tassertNotNull(manager);\n\t\tassertFalse(manager.contains(tempFolder.toURI()));\n\n\t\tProfileMetadataRepositoryFactory factory = new ProfileMetadataRepositoryFactory();\n\t\tProfileMetadataRepository repo = null;\n\t\ttry {\n\t\t\trepo = (ProfileMetadataRepository) factory.load(timeStampedProfile.toURI(), 0, getMonitor());\n\t\t} catch (ProvisionException e1) {\n\t\t\tfail();\n\t\t}\n\n\t\tCollector repoCollector = repo.query(InstallableUnitQuery.ANY, new Collector(), getMonitor());\n\t\tassertFalse(repoCollector.isEmpty());\n\t\tassertTrue(repoCollector.toCollection().containsAll(profileCollector.toCollection()));\n\n\t\tassertTrue(manager.contains(tempFolder.toURI()));\n\t\tassertTrue(manager.contains(defaultAgenRepositoryDirectory.toURI()));\n\t}\n",
      "fixed": "\tpublic void testDefaultAgentRepoAndBundlePoolFromProfileRepo() throws InterruptedException {\n\t\tFile testData = getTestData(\"0.1\", \"testData/sdkpatchingtest\");\n\t\t// /p2/org.eclipse.equinox.p2.engine/profileRegistry\");\n\t\tFile tempFolder = getTempFolder();\n\t\tcopy(\"0.2\", testData, tempFolder);\n\t\tnew SimpleArtifactRepositoryFactory().create(tempFolder.toURI(), \"\", \"\", null);\n\n\t\tFile defaultAgenRepositoryDirectory = new File(tempFolder, \"p2/org.eclipse.equinox.p2.core\");\n\t\tnew SimpleArtifactRepositoryFactory().create(defaultAgenRepositoryDirectory.toURI(), \"\", \"\", null);\n\n\t\tFile profileRegistryFolder = new File(tempFolder, \"p2/org.eclipse.equinox.p2.engine/profileRegistry\");\n\t\tSimpleProfileRegistry registry = new SimpleProfileRegistry(profileRegistryFolder, null, false);\n\t\tIProfile profile = registry.getProfile(\"SDKProfile\");\n\t\tassertNotNull(profile);\n\n\t\tCollector profileCollector = profile.query(InstallableUnitQuery.ANY, new Collector(), getMonitor());\n\t\tassertFalse(profileCollector.isEmpty());\n\n\t\tFile simpleProfileFolder = new File(profileRegistryFolder, \"SDKProfile.profile\");\n\t\tassertTrue(simpleProfileFolder.exists());\n\n\t\tFile timeStampedProfile = new File(simpleProfileFolder, \"\" + profile.getTimestamp() + \".profile\");\n\t\tassertTrue(timeStampedProfile.exists());\n\n\t\tIArtifactRepositoryManager manager = (IArtifactRepositoryManager) ServiceHelper.getService(TestActivator.context, IArtifactRepositoryManager.class.getName());\n\t\tassertNotNull(manager);\n\t\tassertFalse(manager.contains(tempFolder.toURI()));\n\n\t\tProfileMetadataRepositoryFactory factory = new ProfileMetadataRepositoryFactory();\n\t\tProfileMetadataRepository repo = null;\n\t\ttry {\n\t\t\trepo = (ProfileMetadataRepository) factory.load(timeStampedProfile.toURI(), 0, getMonitor());\n\t\t} catch (ProvisionException e1) {\n\t\t\tfail();\n\t\t}\n\n\t\tCollector repoCollector = repo.query(InstallableUnitQuery.ANY, new Collector(), getMonitor());\n\t\tassertFalse(repoCollector.isEmpty());\n\t\tassertTrue(repoCollector.toCollection().containsAll(profileCollector.toCollection()));\n\n\t\tint maxTries = 20;\n\t\tint current = 0;\n\t\twhile (true) {\n\t\t\tif (manager.contains(tempFolder.toURI()) && manager.contains(defaultAgenRepositoryDirectory.toURI()))\n\t\t\t\tbreak;\n\t\t\tif (++current == maxTries)\n\t\t\t\tfail(\"profile artifact repos not added\");\n\t\t\tThread.sleep(100);\n\t\t}\n\t}\n"
    }
  ]
}